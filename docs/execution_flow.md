# RobinPath Execution Flow

This document describes how the RobinPath Interpreter executes the Abstract Syntax Tree (AST).

## Overview

The execution phase takes the AST generated by the Parser and runs it. The `Executor` class is the core engine, managing the call stack, scopes, and flow control.

## Mermaid Diagram

```mermaid
flowchart TD
    Start([AST Statement[]]) --> Executor
    
    subgraph Executor [Execution Engine]
        direction TB
        E_Init[Initialize Environment & Global Scope]
        E_Run[execute(statements)]
        E_Loop{Iterate Statements}
        
        E_Init --> E_Run
        E_Run --> E_Loop
        
        E_Loop -- Done --> E_End([Finish])
        E_Loop -- Next Stmt --> E_Dispatch{Dispatch Statement Type}
        
        %% Control Flow
        E_Dispatch -- "IF" --> E_If[executeIf]
        E_If --> E_EvalCond[Evaluate Condition]
        E_EvalCond -- True --> E_ExecCons[Execute Consequent Block]
        E_EvalCond -- False --> E_ExecAlt[Execute Else/ElseIf Block]
        E_ExecCons --> E_Loop
        E_ExecAlt --> E_Loop
        
        E_Dispatch -- "FOR" --> E_For[executeFor]
        E_For --> E_EvalIter[Evaluate Iterable]
        E_For --> E_LoopIter{Iterate Items}
        E_LoopIter -- Item --> E_ExecBody[Execute Body]
        E_ExecBody --> E_LoopIter
        E_LoopIter -- Done --> E_Loop
        
        %% Commands & Calls
        E_Dispatch -- "COMMAND" --> E_Cmd[executeCommand]
        E_Cmd --> E_ResolveCmd[Resolve Function/Command]
        E_ResolveCmd -- Native --> E_CallNative[Call Native Function]
        E_ResolveCmd -- User Def --> E_CallDef[Call User Function]
        
        subgraph FunctionCall [Function Execution]
            E_CallDef --> FC_Push[Push New Stack Frame]
            FC_Push --> FC_Args[Map Arguments]
            FC_Args --> FC_Exec[Execute Body Statements]
            FC_Exec --> FC_Pop[Pop Stack Frame]
            FC_Pop --> FC_Ret[Return Value]
        end
        
        E_CallNative --> E_HandleInto[Handle 'into' Clause]
        FC_Ret --> E_HandleInto
        E_HandleInto --> E_Loop
        
        %% Assignments
        E_Dispatch -- "ASSIGNMENT" --> E_Assign[executeAssignment]
        E_Assign --> E_EvalVal[Evaluate Value]
        E_EvalVal --> E_SetVar[setVariable]
        E_SetVar --> E_Loop
        
        %% Parallel Execution
        E_Dispatch -- "TOGETHER" --> E_Together[executeTogether]
        E_Together --> E_Spawn[Spawn Child Threads]
        E_Spawn --> E_Wait[Wait for All]
        E_Wait --> E_Loop
        
        %% Subexpressions
        E_Dispatch -- "SUBEXPRESSION" --> E_Sub[executeSubexpression]
        E_Sub --> E_ExecSub[Execute Inner Statements]
        E_ExecSub --> E_Loop
        
        %% Flow Control
        E_Dispatch -- "RETURN" --> E_RetEx[Throw ReturnException]
        E_Dispatch -- "BREAK" --> E_BrkEx[Throw BreakException]
        E_Dispatch -- "CONTINUE" --> E_CntEx[Throw ContinueException]
        
        E_RetEx -.-> Catch[Catch Exception in Caller]
        E_BrkEx -.-> CatchLoop[Catch in Loop]
        E_CntEx -.-> CatchLoop
    end
```

## Key Components

### 1. Executor (`Executor.ts`)
The `Executor` maintains the runtime state.
- **Environment**: Holds global configurations, registered modules, and global variables.
- **Call Stack**: A stack of `Frame` objects. Each frame represents a function call or a scope, containing local variables.
- **Recursion Guard**: Tracks depth to prevent infinite recursion (limit ~60k).

### 2. Execution Loop
The `execute` method iterates over the list of statements. It uses a `switch` statement (or similar dispatch mechanism) to handle each statement type.

### 3. Variable Resolution
Variables are resolved dynamically.
- **Reading**: Checks the current frame's locals, then walks up the stack (unless isolated), then checks globals.
- **Writing**: Updates the variable where it is found (local, parent, or global). If new, it defaults to the appropriate scope (local for functions, global otherwise).

### 4. Function Calls
- **Native Functions**: Executed directly (JavaScript functions registered in the environment).
- **User Functions (`def`)**:
    1.  A new `Frame` is pushed to the `callStack`.
    2.  Arguments are mapped to local variables in that frame.
    3.  The function body (Statement list) is executed recursively.
    4.  The frame is popped.

### 5. Control Flow (Exceptions)
Flow control statements like `return`, `break`, and `continue` work by throwing specific internal exceptions (`ReturnException`, `BreakException`, `ContinueException`). These are caught by the specific parent handlers (e.g., `executeFor` catches `BreakException`).

### 6. Parallel Execution (`together`)
The `together` block executes statements in parallel.
- Spawns independent "Child Threads" (instances of `RobinPathThread` or isolated execution contexts).
- Each thread gets its own stack to prevent race conditions.
- The parent waits for all threads to complete (`Promise.all`).
