/**
 * RobinPath Interpreter
 * 
 * See README.md for full documentation and usage examples.
 */

// RobinPath Interpreter Implementation

// Module adapter interface
export interface ModuleAdapter {
    name: string;
    functions: Record<string, BuiltinHandler>;
    functionMetadata: Record<string, FunctionMetadata>;
    moduleMetadata: ModuleMetadata;
    global?: boolean; // If true, register functions globally (without module prefix)
}

import JSON5 from 'json5';

// Import utilities
import { 
    splitIntoLogicalLines, 
    LexerUtils, 
    valueToJS, 
    evalExpression, 
    isTruthy,
    extractNamedArgs,
    type Value,
    type AttributePathSegment
} from './utils';

// Import classes
import {
    Lexer,
    Parser,
    ExpressionEvaluator,
    Executor,
    ExecutionStateTracker,
    ReturnException,
    BreakException,
    EndException,
    RobinPathThread
} from './classes';

// Re-export types for external use
export type { Value, AttributePathSegment };

// Import core modules
import CoreModule from './modules/Core';
import MathModule from './modules/Math';
import StringModule from './modules/String';
import JsonModule from './modules/Json';
import ObjectModule from './modules/Object';
import TimeModule from './modules/Time';
import RandomModule from './modules/Random';
import ArrayModule from './modules/Array';
import FetchModule from './modules/Fetch';
import TestModule from './modules/Test';

// ============================================================================
// Types
// ============================================================================

// Value type is imported from utils

interface Environment {
    variables: Map<string, Value>;
    functions: Map<string, DefineFunction>;
    builtins: Map<string, BuiltinHandler>;
    metadata: Map<string, FunctionMetadata>;
    moduleMetadata: Map<string, ModuleMetadata>;
    currentModule: string | null; // Current module context set by "use" command
    variableMetadata: Map<string, Map<string, Value>>; // variable name -> (meta key -> value)
    functionMetadata: Map<string, Map<string, Value>>; // function name -> (meta key -> value)
}

interface Frame {
    locals: Map<string, Value>;
    lastValue: Value;
    isFunctionFrame?: boolean; // True if this frame is from a function (def/enddef), false/undefined if from subexpression
    forgotten?: Set<string>; // Names of variables/functions forgotten in this scope
    isIsolatedScope?: boolean; // True if this frame is from a scope with parameters (isolated, no parent access)
}

export type BuiltinHandler = (args: Value[]) => Value | Promise<Value>;

// extractNamedArgs is imported from utils
export { extractNamedArgs };

// ============================================================================
// Metadata Types
// ============================================================================

export type DataType = 'string' | 'number' | 'boolean' | 'object' | 'array' | 'null' | 'any';

export type FormInputType = 
    | 'text' 
    | 'number' 
    | 'textarea' 
    | 'select' 
    | 'checkbox' 
    | 'radio' 
    | 'date' 
    | 'datetime' 
    | 'file' 
    | 'json'
    | 'code';

export interface ParameterMetadata {
    name: string;
    label?: string; // Display label for the parameter (e.g., "Arguments" for variadic parameters)
    dataType: DataType;
    description: string;
    formInputType: FormInputType;
    required?: boolean;
    defaultValue?: Value;
    children?: ParameterMetadata; // Schema for array/list items (for variable arguments)
}

export interface FunctionMetadata {
    description: string;
    parameters: ParameterMetadata[];
    returnType: DataType;
    returnDescription: string;
    example?: string; // Optional example usage
}

export interface ModuleMetadata {
    description: string;
    methods: string[];
}

// AttributePathSegment type is imported from utils

type Arg = 
    | { type: 'subexpr'; code: string }   // $( ... ) inline subexpression
    | { type: 'var'; name: string; path?: AttributePathSegment[] }  // $var or $var.property or $var[0] or $var.property[0]
    | { type: 'lastValue' }
    | { type: 'literal'; value: Value }
    | { type: 'number'; value: number }
    | { type: 'string'; value: string }
    | { type: 'object'; code: string }    // { ... } object literal
    | { type: 'array'; code: string }     // [ ... ] array literal
    | { type: 'namedArgs'; args: Record<string, Arg> }; // Named arguments object (key=value pairs)

interface CommandCall {
    type: 'command';
    name: string;
    args: Arg[];
    comments?: string[]; // Comments attached to this command (above and inline)
}

interface Assignment {
    type: 'assignment';
    targetName: string;
    targetPath?: AttributePathSegment[]; // Path for attribute access assignment (e.g., $animal.cat)
    command?: CommandCall;
    literalValue?: Value;
    isLastValue?: boolean; // True if assignment is from $ (last value)
    comments?: string[]; // Comments attached to this assignment (above and inline)
}

interface ShorthandAssignment {
    type: 'shorthand';
    targetName: string;
    comments?: string[]; // Comments attached to this shorthand assignment (above and inline)
}

interface InlineIf {
    type: 'inlineIf';
    conditionExpr: string;
    command: Statement;
    comments?: string[]; // Comments attached to this inline if (above and inline)
}

interface IfBlock {
    type: 'ifBlock';
    conditionExpr: string;
    thenBranch: Statement[];
    elseBranch?: Statement[];
    elseifBranches?: Array<{ condition: string; body: Statement[] }>;
    comments?: string[]; // Comments attached to this if block (above and inline)
}

interface IfTrue {
    type: 'ifTrue';
    command: Statement;
    comments?: string[]; // Comments attached to this iftrue (above and inline)
}

interface IfFalse {
    type: 'ifFalse';
    command: Statement;
    comments?: string[]; // Comments attached to this iffalse (above and inline)
}

interface DefineFunction {
    type: 'define';
    name: string;
    paramNames: string[]; // Parameter names (e.g., ['a', 'b', 'c']) - aliases for $1, $2, $3
    body: Statement[];
    comments?: string[]; // Comments attached to this function definition (above and inline)
}

interface ScopeBlock {
    type: 'scope';
    paramNames?: string[]; // Optional parameter names (e.g., ['a', 'b'])
    body: Statement[];
    comments?: string[]; // Comments attached to this scope block (above and inline)
}

interface ForLoop {
    type: 'forLoop';
    varName: string;
    iterableExpr: string;
    body: Statement[];
    comments?: string[]; // Comments attached to this for loop (above and inline)
}

interface ReturnStatement {
    type: 'return';
    value?: Arg; // Optional value to return (if not provided, returns $)
    comments?: string[]; // Comments attached to this return statement (above and inline)
}

interface BreakStatement {
    type: 'break';
    comments?: string[]; // Comments attached to this break statement (above and inline)
}

interface CommentStatement {
    type: 'comment';
    text?: string; // Comment text without the # (for single comments)
    comments?: string[]; // Array of comment texts (for grouped orphaned comments)
    lineNumber: number; // Original line number for reference
}

type Statement = 
    | CommandCall 
    | Assignment 
    | ShorthandAssignment 
    | InlineIf 
    | IfBlock 
    | IfTrue 
    | IfFalse 
    | DefineFunction
    | ScopeBlock
    | ForLoop
    | ReturnStatement
    | BreakStatement
    | CommentStatement;

// ============================================================================
// Logical Line Splitter
// ============================================================================

// splitIntoLogicalLines and handleBackslashContinuation are imported from utils

// ============================================================================
// Lexer
// ============================================================================

// Lexer is imported from classes

// ============================================================================
// Parser
// ============================================================================

// Parser is imported from classes
    private lines: string[];
    private currentLine: number = 0;

    constructor(lines: string[]) {
        this.lines = lines;
    }

    /**
     * Helper function to create a comment node from orphaned comments
     * For a single comment, uses 'text' property
     * For multiple comments, uses 'comments' array
     */
    private createGroupedCommentNode(comments: string[], commentLines: number[]): CommentStatement {
        // Ensure we have comments to group
        if (comments.length === 0) {
            throw new Error('createGroupedCommentNode called with empty comments array');
        }
        // Use the first line number as the reference
        if (comments.length === 1) {
            // Single comment - use 'text' property
            return {
                type: 'comment',
                text: comments[0],
                lineNumber: commentLines[0]
            };
        } else {
            // Multiple comments - use 'comments' array
            return {
                type: 'comment',
                comments: comments,
                lineNumber: commentLines[0]
            };
        }
    }

    private getLineContent(lineNumber: number): string {
        if (lineNumber >= 0 && lineNumber < this.lines.length) {
            return this.lines[lineNumber].trim();
        }
        return '';
    }

    private createError(message: string, lineNumber: number): Error {
        const lineContent = this.getLineContent(lineNumber);
        const lineInfo = lineContent ? `\n  Line content: ${lineContent}` : '';
        return new Error(`Line ${lineNumber + 1}: ${message}${lineInfo}`);
    }

    parse(): Statement[] {
        // First pass: extract all def/enddef blocks and mark their line numbers
        const defBlockLines = new Set<number>();
        const extractedFunctions: DefineFunction[] = [];
        let scanLine = 0;
        
        while (scanLine < this.lines.length) {
            const line = this.lines[scanLine].trim();
            
            // Skip empty lines and comments when scanning for def blocks
            if (!line || line.startsWith('#')) {
                scanLine++;
                continue;
            }
            
            const tokens = Lexer.tokenize(line);
            if (tokens.length > 0 && tokens[0] === 'def') {
                // Found a def block - extract it
                const savedCurrentLine = this.currentLine;
                this.currentLine = scanLine;
                const func = this.parseDefine();
                extractedFunctions.push(func);
                
                // Mark all lines in this def block (from def to enddef)
                const startLine = scanLine;
                const endLine = this.currentLine - 1; // parseDefine advances past enddef
                for (let i = startLine; i <= endLine; i++) {
                    defBlockLines.add(i);
                }
                
                scanLine = this.currentLine;
                this.currentLine = savedCurrentLine;
            } else {
                scanLine++;
            }
        }
        
        // Extract nested def blocks from function bodies
        const allExtractedFunctions = [...extractedFunctions];
        const extractNestedDefs = (statements: Statement[]): void => {
            for (const stmt of statements) {
                if (stmt.type === 'define') {
                    // Found a nested def - extract it and remove from parent body
                    allExtractedFunctions.push(stmt);
                    // Note: We'll remove it from the parent body later
                } else if (stmt.type === 'ifBlock') {
                    // Check branches for nested defs
                    if (stmt.thenBranch) extractNestedDefs(stmt.thenBranch);
                    if (stmt.elseifBranches) {
                        for (const branch of stmt.elseifBranches) {
                            extractNestedDefs(branch.body);
                        }
                    }
                    if (stmt.elseBranch) extractNestedDefs(stmt.elseBranch);
                } else if (stmt.type === 'forLoop') {
                    if (stmt.body) extractNestedDefs(stmt.body);
                } else if (stmt.type === 'scope') {
                    if (stmt.body) extractNestedDefs(stmt.body);
                }
            }
        };
        
        // Extract nested defs from already-extracted functions
        for (const func of extractedFunctions) {
            extractNestedDefs(func.body);
        }
        
        // Remove nested def statements from function bodies
        const removeNestedDefs = (statements: Statement[]): Statement[] => {
            return statements.filter(stmt => stmt.type !== 'define');
        };
        
        for (const func of extractedFunctions) {
            func.body = removeNestedDefs(func.body);
            // Also remove nested defs from nested blocks
            func.body = func.body.map(stmt => {
                if (stmt.type === 'ifBlock') {
                    return {
                        ...stmt,
                        thenBranch: stmt.thenBranch ? removeNestedDefs(stmt.thenBranch) : undefined,
                        elseifBranches: stmt.elseifBranches?.map(branch => ({
                            ...branch,
                            body: removeNestedDefs(branch.body)
                        })),
                        elseBranch: stmt.elseBranch ? removeNestedDefs(stmt.elseBranch) : undefined
                    };
                } else if (stmt.type === 'forLoop') {
                    return {
                        ...stmt,
                        body: removeNestedDefs(stmt.body)
                    };
                } else if (stmt.type === 'scope') {
                    return {
                        ...stmt,
                        body: removeNestedDefs(stmt.body)
                    };
                }
                return stmt;
            }) as Statement[];
        }
        
        // Store all extracted functions (including nested ones) for later registration
        (this as any).extractedFunctions = allExtractedFunctions;
        
        // Second pass: parse remaining statements (excluding def blocks)
        // Collect comments and attach them to the following statement
        this.currentLine = 0;
        const pendingComments: string[] = [];
        const statements = this.parseStatementsWithComments(
            pendingComments,
            (lineNumber) => defBlockLines.has(lineNumber)
        );

        return statements;
    }
    
    /**
     * Get extracted function definitions (def/enddef blocks) that were parsed separately
     */
    getExtractedFunctions(): DefineFunction[] {
        return (this as any).extractedFunctions || [];
    }

    /**
     * Extract inline comment from a line (comment after code on the same line)
     * Returns the comment text without the #, or null if no inline comment found
     */
    private extractInlineComment(line: string): string | null {
        let inString: false | '"' | "'" | '`' = false;
        let escaped = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            // Handle string boundaries
            if (!escaped && (char === '"' || char === "'" || char === '`')) {
                if (!inString) {
                    inString = char;
                } else if (char === inString) {
                    inString = false;
                }
                escaped = false;
                continue;
            }
            
            if (inString) {
                escaped = char === '\\' && !escaped;
                continue;
            }
            
            // Check for comment character (not inside string)
            if (char === '#') {
                const commentText = line.slice(i + 1).trim();
                return commentText || null;
            }
            
            escaped = false;
        }
        
        return null;
    }

    /**
     * Parse statements with comment collection
     * Rules:
     * 1. Collect consecutive comments directly above a statement (no blank lines between)
     * 2. Collect inline comments on the same line as the statement
     * Blank lines break the comment sequence - unattached comments become CommentStatement nodes
     */
    private parseStatementsWithComments(
        pendingComments: string[],
        shouldSkipLine?: (lineNumber: number) => boolean
    ): Statement[] {
        const statements: Statement[] = [];
        const pendingCommentLines: number[] = []; // Track line numbers for pending comments
        let hasBlankLineAfterLastComment = false; // Track if blank line appeared after last comment
        let hasCreatedCommentNodes = false; // Track if we've created comment nodes (indicates comment->blank->comment pattern)
        
        while (this.currentLine < this.lines.length) {
            if (shouldSkipLine && shouldSkipLine(this.currentLine)) {
                this.currentLine++;
                continue;
            }
            
            const originalLine = this.lines[this.currentLine];
            const line = originalLine.trim();
            
            // Blank line: mark that blank line appeared after last comment
            if (!line) {
                hasBlankLineAfterLastComment = true;
                this.currentLine++;
                continue;
            }
            
            // Comment line: if we have pending comments with blank line after, create comment nodes
            // Then start a new sequence with this comment
            if (line.startsWith('#')) {
                const commentText = line.slice(1).trim();
                
                // If we have pending comments and there was a blank line after them, create comment nodes
                // This happens when: comment -> blank line -> comment (first comment becomes node)
                if (pendingComments.length > 0 && hasBlankLineAfterLastComment) {
                    // Group consecutive orphaned comments into a single node
                    // Make a copy of the arrays before clearing them
                    const commentsToGroup = [...pendingComments];
                    const linesToGroup = [...pendingCommentLines];
                    statements.push(this.createGroupedCommentNode(commentsToGroup, linesToGroup));
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                    hasCreatedCommentNodes = true; // Mark that we've created comment nodes
                } else if (!hasBlankLineAfterLastComment) {
                    // Consecutive comment (no blank line) - reset flag so they can be attached
                    hasCreatedCommentNodes = false;
                }
                
                // Start new sequence with this comment
                pendingComments.push(commentText);
                pendingCommentLines.push(this.currentLine);
                hasBlankLineAfterLastComment = false; // Reset flag
                this.currentLine++;
                continue;
            }

            // Statement: attach pending comments + inline comment
            // If we've created comment nodes before (comment->blank->comment pattern), 
            // remaining comments should also be nodes
            
            // First, handle pending comments BEFORE parsing the statement
            // This ensures we don't lose pending comments if parseStatement() consumes lines
            if (pendingComments.length > 0 && hasBlankLineAfterLastComment) {
                // Blank line after comments - create comment nodes (not attached to statement)
                // Group consecutive orphaned comments into a single node
                // Make a copy of the arrays before clearing them
                const commentsToGroup = [...pendingComments];
                const linesToGroup = [...pendingCommentLines];
                statements.push(this.createGroupedCommentNode(commentsToGroup, linesToGroup));
                pendingComments.length = 0;
                pendingCommentLines.length = 0;
                hasCreatedCommentNodes = true;
            }
            
            const stmt = this.parseStatement();
            if (stmt) {
                const allComments: string[] = [];
                
                // If there are still pending comments (no blank line), attach them
                if (pendingComments.length > 0) {
                    // No blank line after comments - attach them (consecutive comments)
                    allComments.push(...pendingComments);
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                
                // Add inline comment from same line
                const inlineComment = this.extractInlineComment(originalLine);
                if (inlineComment) {
                    allComments.push(inlineComment);
                }
                
                // Attach to statement
                if (allComments.length > 0) {
                    (stmt as any).comments = allComments;
                }
                
                statements.push(stmt);
                hasBlankLineAfterLastComment = false; // Reset flag
                hasCreatedCommentNodes = false; // Reset flag after statement
            } else {
                // parseStatement() returned null (blank line or comment)
                // Reset flags if needed
                hasBlankLineAfterLastComment = false;
            }
        }

        // Handle any remaining pending comments at end of file
        // Group consecutive orphaned comments into a single node
        if (pendingComments.length > 0) {
            // Make a copy of the arrays before clearing them
            const commentsToGroup = [...pendingComments];
            const linesToGroup = [...pendingCommentLines];
            statements.push(this.createGroupedCommentNode(commentsToGroup, linesToGroup));
        }

        return statements;
    }

    private parseStatement(): Statement | null {
        if (this.currentLine >= this.lines.length) return null;

        const line = this.lines[this.currentLine].trim();
        if (!line || line.startsWith('#')) {
            this.currentLine++;
            return null;
        }

        const tokens = Lexer.tokenize(line);

        if (tokens.length === 0) {
            this.currentLine++;
            return null;
        }

        // Check for define block
        if (tokens[0] === 'def') {
            return this.parseDefine();
        }

        // Check for scope block
        if (tokens[0] === 'scope') {
            return this.parseScope();
        }

        // Check for for loop
        if (tokens[0] === 'for') {
            return this.parseForLoop();
        }

        // Check for return statement
        if (tokens[0] === 'return') {
            return this.parseReturn();
        }

        // Check for break statement
        if (tokens[0] === 'break') {
            this.currentLine++;
            return { type: 'break' };
        }

        // Check for block if
        if (tokens[0] === 'if' && !tokens.includes('then')) {
            return this.parseIfBlock();
        }

        // Check for inline if
        if (tokens[0] === 'if' && tokens.includes('then')) {
            return this.parseInlineIf();
        }

        // Check for iftrue/iffalse
        if (tokens[0] === 'iftrue') {
            this.currentLine++;
            const restTokens = tokens.slice(1);
            const command = this.parseCommandFromTokens(restTokens);
            return { type: 'ifTrue', command };
        }

        if (tokens[0] === 'iffalse') {
            this.currentLine++;
            const restTokens = tokens.slice(1);
            const command = this.parseCommandFromTokens(restTokens);
            return { type: 'ifFalse', command };
        }

        // Check for assignment
        if (tokens.length >= 3 && LexerUtils.isVariable(tokens[0]) && tokens[1] === '=') {
            // Parse the target variable name (can include attribute paths like $animal.cat)
            const targetVar = tokens[0];
            const { name: targetName, path: targetPath } = LexerUtils.parseVariablePath(targetVar);
            const restTokens = tokens.slice(2);
            
            // Check if it's a literal value (number, string, boolean, null, or $)
            if (restTokens.length === 1) {
                const token = restTokens[0].trim(); // Ensure token is trimmed
                if (LexerUtils.isLastValue(token)) {
                    // Special case: $var = $ means assign last value
                    // This is handled by executeAssignment which will use frame.lastValue
                    this.currentLine++;
                    return { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: null, // Will be resolved at execution time from frame.lastValue
                        isLastValue: true
                    };
                } else if (token === 'true') {
                    // Check for boolean true BEFORE checking for variables
                    this.currentLine++;
                    return { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: true 
                    };
                } else if (token === 'false') {
                    // Check for boolean false BEFORE checking for variables
                    this.currentLine++;
                    return { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: false 
                    };
                } else if (token === 'null') {
                    // Check for null BEFORE checking for variables
                    this.currentLine++;
                    return { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: null 
                    };
                } else if (LexerUtils.isPositionalParam(token)) {
                    // Special case: $var1 = $1 means assign positional param value
                    const varName = token.slice(1);
                    this.currentLine++;
                    return {
                        type: 'assignment',
                        targetName,
                        targetPath,
                        command: {
                            type: 'command',
                            name: '_var', // Special internal command name
                            args: [{ type: 'var', name: varName }]
                        }
                    };
                } else if (LexerUtils.isVariable(token)) {
                    // Special case: $var1 = $var2 means assign variable value
                    // Create a command that just references the variable
                    const { name: varName, path } = LexerUtils.parseVariablePath(token);
                    this.currentLine++;
                    return {
                        type: 'assignment',
                        targetName,
                        targetPath,
                        command: {
                            type: 'command',
                            name: '_var', // Special internal command name
                            args: [{ type: 'var', name: varName, path }]
                        }
                    };
                } else if (LexerUtils.isNumber(token)) {
                    this.currentLine++;
                    return { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: parseFloat(token) 
                    };
                } else if (LexerUtils.isString(token)) {
                    this.currentLine++;
                    return { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: LexerUtils.parseString(token) 
                    };
                }
            }
            
            // Check if all remaining tokens are string literals (automatic concatenation)
            // This handles cases like: $var = "hello " "world " "from RobinPath"
            if (restTokens.length > 1 && restTokens.every(token => LexerUtils.isString(token))) {
                // Concatenate all string literals
                const concatenated = restTokens.map(token => LexerUtils.parseString(token)).join('');
                this.currentLine++;
                return {
                    type: 'assignment',
                    targetName,
                    targetPath,
                    literalValue: concatenated
                };
            }
            
            // Check if the assignment value is a subexpression $(...), object {...}, or array [...]
            // We need to check the original line because tokenization may have split these incorrectly
            const line = this.lines[this.currentLine];
            const equalsIndex = line.indexOf('=');
            if (equalsIndex !== -1) {
                let pos = equalsIndex + 1;
                // Skip whitespace after "="
                while (pos < line.length && /\s/.test(line[pos])) {
                    pos++;
                }
                // Check if we're at a $( subexpression
                if (pos < line.length - 1 && line[pos] === '$' && line[pos + 1] === '(') {
                    // Extract the subexpression code
                    const subexprCode = this.extractSubexpression(line, pos);
                    this.currentLine++;
                    return {
                        type: 'assignment',
                        targetName,
                        targetPath,
                        command: {
                            type: 'command',
                            name: '_subexpr', // Special internal command name for subexpressions
                            args: [{ type: 'subexpr', code: subexprCode.code }]
                        }
                    };
                }
                // Check if we're at an object literal {
                if (pos < line.length && line[pos] === '{') {
                    const objCode = this.extractObjectLiteral(line, pos);
                    this.currentLine++;
                    return {
                        type: 'assignment',
                        targetName,
                        targetPath,
                        command: {
                            type: 'command',
                            name: '_object',
                            args: [{ type: 'object', code: objCode.code }]
                        }
                    };
                }
                // Check if we're at an array literal [
                if (pos < line.length && line[pos] === '[') {
                    const arrCode = this.extractArrayLiteral(line, pos);
                    this.currentLine++;
                    return {
                        type: 'assignment',
                        targetName,
                        targetPath,
                        command: {
                            type: 'command',
                            name: '_array',
                            args: [{ type: 'array', code: arrCode.code }]
                        }
                    };
                }
            }
            
            // Otherwise, treat as command
            const command = this.parseCommandFromTokens(restTokens);
            this.currentLine++;
            return { type: 'assignment', targetName, targetPath, command };
        }

        // Check if line starts with object or array literal
        const currentLine = this.lines[this.currentLine].trim();
        if (currentLine.startsWith('{')) {
            const objCode = this.extractObjectLiteral(this.lines[this.currentLine], this.lines[this.currentLine].indexOf('{'));
            // extractObjectLiteral sets this.currentLine to the line containing the closing brace
            // We need to move past that line
            this.currentLine++;
            return {
                type: 'command',
                name: '_object', // Special internal command for object literals
                args: [{ type: 'object', code: objCode.code }]
            };
        }
        if (currentLine.startsWith('[')) {
            const arrCode = this.extractArrayLiteral(this.lines[this.currentLine], this.lines[this.currentLine].indexOf('['));
            // extractArrayLiteral sets this.currentLine to the line containing the closing bracket
            // We need to move past that line
            this.currentLine++;
            return {
                type: 'command',
                name: '_array', // Special internal command for array literals
                args: [{ type: 'array', code: arrCode.code }]
            };
        }

        // Check for shorthand assignment or positional param reference
        if (tokens.length === 1) {
            if (LexerUtils.isVariable(tokens[0])) {
                const targetVar = tokens[0];
                // For shorthand assignment, only allow simple variable names (reading attributes is allowed)
                // If it has a path, it's just a reference, not an assignment
                if (/^\$[A-Za-z_][A-Za-z0-9_]*$/.test(targetVar)) {
                    // Simple variable - shorthand assignment
                    const targetName = targetVar.slice(1);
                this.currentLine++;
                return { type: 'shorthand', targetName };
                } else {
                    // Variable with path - just a reference, treat as no-op (or could be used in expressions)
                    // For now, we'll treat it as a no-op since we can't assign to attributes
                    this.currentLine++;
                    return null;
                }
            } else if (LexerUtils.isPositionalParam(tokens[0])) {
                // Positional params alone on a line are no-ops (just references)
                // They're used for documentation/clarity in function definitions
                this.currentLine++;
                return { type: 'shorthand', targetName: tokens[0].slice(1) };
            } else if (LexerUtils.isLastValue(tokens[0])) {
                // Just $ on a line is a no-op (just references the last value, doesn't assign)
                // This is useful in subexpressions or for clarity
                // We'll create a no-op statement by using a comment-like approach
                // Actually, we can just skip it - it's effectively a no-op
                this.currentLine++;
                return null; // No-op statement
            }
        }

        // Check if this is a parenthesized function call: fn(...) or module.fn(...)
        // Look for pattern: identifier followed by '(' OR module.identifier followed by '('
        if ((tokens.length >= 2 && tokens[1] === '(') || 
            (tokens.length >= 4 && tokens[1] === '.' && tokens[3] === '(')) {
            // This is a parenthesized call - parse it specially
            // Note: parseParenthesizedCall already updates this.currentLine via extractParenthesizedContent
            const command = this.parseParenthesizedCall(tokens);
            return command;
        }

        // Regular command
        const command = this.parseCommandFromTokens(tokens);
        this.currentLine++;
        return command;
    }

    /**
     * Parse a parenthesized function call: fn(...)
     * Supports both positional and named arguments (key=value)
     * Handles multi-line calls
     */
    private parseParenthesizedCall(tokens: string[]): CommandCall {
        // Get function name (handle module.function syntax)
        let name: string;
        if (tokens.length >= 4 && tokens[1] === '.' && tokens[3] === '(') {
            // Module function: math.add(...)
            name = `${tokens[0]}.${tokens[2]}`;
        } else if (tokens.length >= 2 && tokens[1] === '(') {
            // Regular function: fn(...)
            name = tokens[0];
        } else {
            throw this.createError('expected ( after function name', this.currentLine);
        }

        // Validate function name
        if (LexerUtils.isNumber(name)) {
            throw this.createError(`expected command name, got number: ${name}`, this.currentLine);
        }
        if (LexerUtils.isString(name)) {
            throw this.createError(`expected command name, got string literal: ${name}`, this.currentLine);
        }
        if (LexerUtils.isVariable(name) || LexerUtils.isPositionalParam(name)) {
            throw this.createError(`expected command name, got variable: ${name}`, this.currentLine);
        }
        if (LexerUtils.isLastValue(name)) {
            throw this.createError(`expected command name, got last value reference: ${name}`, this.currentLine);
        }

        // Extract content inside parentheses (handles multi-line)
        const parenContent = this.extractParenthesizedContent();
        
        // Parse arguments from the content
        const { positionalArgs, namedArgs } = this.parseParenthesizedArguments(parenContent);

        // Combine positional args and named args (named args as a special object)
        const args: Arg[] = [...positionalArgs];
        if (Object.keys(namedArgs).length > 0) {
            args.push({ type: 'namedArgs', args: namedArgs });
        }

        return { type: 'command', name, args };
    }

    /**
     * Extract content inside parentheses, handling multi-line calls
     * Returns the inner content (without the parentheses)
     */
    private extractParenthesizedContent(): string {
        const startLine = this.currentLine;
        const line = this.lines[startLine].trim();
        
        // Find the opening parenthesis position
        const openParenIndex = line.indexOf('(');
        if (openParenIndex === -1) {
            throw this.createError('expected (', startLine);
        }

        let pos = openParenIndex + 1;
        let depth = 1;
        let inString: false | '"' | "'" | '`' = false;
        const content: string[] = [];
        let currentLineIndex = startLine;

        while (currentLineIndex < this.lines.length && depth > 0) {
            const currentLine = this.lines[currentLineIndex];
            
            while (pos < currentLine.length && depth > 0) {
                const char = currentLine[pos];
                const prevChar = pos > 0 ? currentLine[pos - 1] : '';

                // Handle strings
                if ((char === '"' || char === "'" || char === '`') && prevChar !== '\\') {
                    if (!inString) {
                        inString = char;
                    } else if (char === inString) {
                        inString = false;
                    }
                    content.push(char);
                    pos++;
                    continue;
                }

                if (inString) {
                    content.push(char);
                    pos++;
                    continue;
                }

                // Handle nested parentheses
                if (char === '(') {
                    depth++;
                    content.push(char);
                } else if (char === ')') {
                    depth--;
                    if (depth > 0) {
                        // This is a closing paren for a nested call
                        content.push(char);
                    }
                    // If depth === 0, we're done - don't include this closing paren
                } else {
                    content.push(char);
                }
                pos++;
            }

            if (depth > 0) {
                // Need to continue on next line
                content.push('\n');
                currentLineIndex++;
                pos = 0;
            }
        }

        if (depth > 0) {
            throw this.createError('unclosed parenthesized function call', startLine);
        }

        // Update currentLine to skip past the line with the closing paren
        this.currentLine = currentLineIndex + 1;

        return content.join('').trim();
    }

    /**
     * Parse arguments from parenthesized content
     * Handles both positional and named arguments (key=value)
     */
    private parseParenthesizedArguments(content: string): { positionalArgs: Arg[]; namedArgs: Record<string, Arg> } {
        const positionalArgs: Arg[] = [];
        const namedArgs: Record<string, Arg> = {};

        if (!content.trim()) {
            return { positionalArgs, namedArgs };
        }

        // Split content into argument tokens
        // Arguments are separated by whitespace (spaces or newlines)
        // But we need to preserve strings and subexpressions
        const argTokens = this.tokenizeParenthesizedArguments(content);

        for (const token of argTokens) {
            // Check if it's a named argument: key=value
            const equalsIndex = token.indexOf('=');
            if (equalsIndex > 0 && equalsIndex < token.length - 1) {
                // Check if = is not inside a string or subexpression
                // Simple check: if token starts with identifier-like chars followed by =, it's named
                const beforeEquals = token.substring(0, equalsIndex).trim();
                const afterEquals = token.substring(equalsIndex + 1).trim();
                
                // Validate key name (must be identifier-like)
                if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(beforeEquals)) {
                    // This is a named argument: key=value
                    const key = beforeEquals;
                    const valueArg = this.parseArgumentValue(afterEquals);
                    namedArgs[key] = valueArg;
                    continue;
                }
            }

            // Positional argument
            const arg = this.parseArgumentValue(token);
            positionalArgs.push(arg);
        }

        return { positionalArgs, namedArgs };
    }

    /**
     * Tokenize arguments from parenthesized content
     * Handles strings, subexpressions, object/array literals, and whitespace separation
     */
    private tokenizeParenthesizedArguments(content: string): string[] {
        const tokens: string[] = [];
        let current = '';
        let inString: false | '"' | "'" | '`' = false;
        let subexprDepth = 0;
        let braceDepth = 0;
        let bracketDepth = 0;
        let i = 0;

        while (i < content.length) {
            const char = content[i];
            const nextChar = i + 1 < content.length ? content[i + 1] : '';
            const prevChar = i > 0 ? content[i - 1] : '';

            // Handle strings
            if ((char === '"' || char === "'" || char === '`') && prevChar !== '\\') {
                if (!inString) {
                    inString = char;
                } else if (char === inString) {
                    inString = false;
                }
                current += char;
                i++;
                continue;
            }

            if (inString) {
                current += char;
                i++;
                continue;
            }

            // Handle $() subexpressions
            if (char === '$' && nextChar === '(') {
                subexprDepth++;
                current += char;
                i++;
                continue;
            }

            if (char === ')' && subexprDepth > 0) {
                subexprDepth--;
                current += char;
                i++;
                continue;
            }

            // Handle object literals { }
            if (char === '{') {
                braceDepth++;
                current += char;
                i++;
                continue;
            }

            if (char === '}' && braceDepth > 0) {
                braceDepth--;
                current += char;
                i++;
                continue;
            }

            // Handle array literals [ ]
            if (char === '[') {
                bracketDepth++;
                current += char;
                i++;
                continue;
            }

            if (char === ']' && bracketDepth > 0) {
                bracketDepth--;
                current += char;
                i++;
                continue;
            }

            // Handle whitespace and commas (only at top level, not inside $(), {}, or [])
            // Commas are optional separators
            if (((char === ' ' || char === '\n' || char === '\t') || char === ',') && 
                subexprDepth === 0 && braceDepth === 0 && bracketDepth === 0) {
                if (current.trim()) {
                    tokens.push(current.trim());
                }
                current = '';
                i++;
                continue;
            }

            current += char;
            i++;
        }

        if (current.trim()) {
            tokens.push(current.trim());
        }

        return tokens.filter(t => t.length > 0);
    }

    /**
     * Parse a single argument value (for both positional and named arguments)
     */
    private parseArgumentValue(token: string): Arg {
        // Check if it's exactly $ (last value without attributes)
        if (token === '$') {
            return { type: 'lastValue' };
        }
        
        // Check if it's a variable
        if (LexerUtils.isVariable(token)) {
            const { name, path } = LexerUtils.parseVariablePath(token);
            return { type: 'var', name, path };
        }
        
        // Check if it's a positional param
        if (LexerUtils.isPositionalParam(token)) {
            return { type: 'var', name: token.slice(1) };
        }
        
        // Check if it's a boolean
        if (token === 'true') {
            return { type: 'literal', value: true };
        }
        if (token === 'false') {
            return { type: 'literal', value: false };
        }
        if (token === 'null') {
            return { type: 'literal', value: null };
        }
        
        // Check if it's a string
        if (LexerUtils.isString(token)) {
            return { type: 'string', value: LexerUtils.parseString(token) };
        }
        
        // Check if it's a number
        if (LexerUtils.isNumber(token)) {
            return { type: 'number', value: parseFloat(token) };
        }
        
        // Check if it's a subexpression $(...)
        if (token.startsWith('$(') && token.endsWith(')')) {
            const code = token.slice(2, -1); // Remove $( and )
            return { type: 'subexpr', code };
        }
        
        // Check if it's an object literal {...}
        if (token.startsWith('{') && token.endsWith('}')) {
            const code = token.slice(1, -1); // Remove { and }
            return { type: 'object', code };
        }
        
        // Check if it's an array literal [...]
        if (token.startsWith('[') && token.endsWith(']')) {
            const code = token.slice(1, -1); // Remove [ and ]
            return { type: 'array', code };
        }
        
        // Treat as literal string
        return { type: 'literal', value: token };
    }

    private parseDefine(): DefineFunction {
        const originalLine = this.lines[this.currentLine];
        const line = originalLine.trim();
        const tokens = Lexer.tokenize(line);
        
        if (tokens.length < 2) {
            throw this.createError('def requires a function name', this.currentLine);
        }

        const name = tokens[1];
        
        // Parse parameter names (optional): def fn $a $b $c
        const paramNames: string[] = [];
        for (let i = 2; i < tokens.length; i++) {
            const token = tokens[i];
            // Parameter names must be variables (e.g., $a, $b, $c)
            if (LexerUtils.isVariable(token) && !LexerUtils.isPositionalParam(token) && !LexerUtils.isLastValue(token)) {
                const { name: paramName } = LexerUtils.parseVariablePath(token);
                if (paramName && /^[A-Za-z_][A-Za-z0-9_]*$/.test(paramName)) {
                    paramNames.push(paramName);
                } else {
                    // Invalid parameter name - stop parsing parameters
                    break;
                }
            } else {
                // Not a valid parameter name - stop parsing parameters
                break;
            }
        }
        
        // Extract inline comment from def line
        const inlineComment = this.extractInlineComment(originalLine);
        const comments: string[] = [];
        if (inlineComment) {
            comments.push(inlineComment);
        }
        
        this.currentLine++;

        const body: Statement[] = [];
        let closed = false;
        let pendingComments: string[] = [];
        const pendingCommentLines: number[] = [];
        let hasBlankLineAfterLastComment = false;
        let hasCreatedCommentNodes = false;

        while (this.currentLine < this.lines.length) {
            const originalBodyLine = this.lines[this.currentLine];
            const bodyLine = originalBodyLine.trim();
            
            // Blank line: mark that blank line appeared after last comment
            if (!bodyLine) {
                hasBlankLineAfterLastComment = true;
                this.currentLine++;
                continue;
            }
            
            // Comment line: if we have pending comments with blank line after, create comment nodes
            if (bodyLine.startsWith('#')) {
                const commentText = bodyLine.slice(1).trim();
                
                // If we have pending comments and there was a blank line after them, create comment nodes
                if (pendingComments.length > 0 && hasBlankLineAfterLastComment) {
                    // Group consecutive orphaned comments into a single node
                    body.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                    hasCreatedCommentNodes = true;
                } else if (!hasBlankLineAfterLastComment) {
                    // Consecutive comment (no blank line) - reset flag so they can be attached
                    hasCreatedCommentNodes = false;
                }
                
                // Start new sequence with this comment
                pendingComments.push(commentText);
                pendingCommentLines.push(this.currentLine);
                hasBlankLineAfterLastComment = false;
                this.currentLine++;
                continue;
            }

            const bodyTokens = Lexer.tokenize(bodyLine);
            
            if (bodyTokens[0] === 'enddef') {
                this.currentLine++;
                closed = true;
                break;
            }

            const stmt = this.parseStatement();
            if (stmt) {
                const allComments: string[] = [];
                
                // If there was a blank line after pending comments, create comment nodes
                if (pendingComments.length > 0 && hasBlankLineAfterLastComment && hasCreatedCommentNodes) {
                    // comment -> blank -> comment -> blank -> statement: all comments become nodes
                    // Group consecutive orphaned comments into a single node
                    body.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                } else if (pendingComments.length > 0 && hasBlankLineAfterLastComment && !hasCreatedCommentNodes) {
                    // comment -> blank -> statement: comment becomes node (not attached)
                    // Group consecutive orphaned comments into a single node
                    body.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                } else if (pendingComments.length > 0) {
                    // No blank line after comments - attach them (consecutive comments)
                    allComments.push(...pendingComments);
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                
                // Inline comment on same line
                const inlineComment = this.extractInlineComment(originalBodyLine);
                if (inlineComment) {
                    allComments.push(inlineComment);
                }
                
                if (allComments.length > 0) {
                    (stmt as any).comments = allComments;
                }
                
                body.push(stmt);
                hasBlankLineAfterLastComment = false;
                hasCreatedCommentNodes = false;
            }
        }

        // Handle any remaining pending comments at end of block
        // Group consecutive orphaned comments into a single node
        if (pendingComments.length > 0) {
            body.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
        }

        if (!closed) {
            throw this.createError('missing enddef', this.currentLine);
        }

        const result: DefineFunction = { type: 'define', name, paramNames, body };
        if (comments.length > 0) {
            result.comments = comments;
        }
        return result;
    }

    private parseScope(): ScopeBlock {
        const originalLine = this.lines[this.currentLine];
        const line = originalLine.trim();
        const tokens = Lexer.tokenize(line);
        
        // Parse parameter names (optional): scope $a $b
        const paramNames: string[] = [];
        
        // Start from token index 1 (after "scope")
        for (let i = 1; i < tokens.length; i++) {
            const token = tokens[i];
            
            // Parameter names must be variables (e.g., $a, $b, $c)
            if (LexerUtils.isVariable(token) && !LexerUtils.isPositionalParam(token) && !LexerUtils.isLastValue(token)) {
                const { name: paramName } = LexerUtils.parseVariablePath(token);
                if (paramName && /^[A-Za-z_][A-Za-z0-9_]*$/.test(paramName)) {
                    paramNames.push(paramName);
                } else {
                    // Invalid parameter name - stop parsing parameters
                    break;
                }
            } else {
                // Not a valid parameter name - stop parsing parameters
                break;
            }
        }
        
        // Extract inline comment from scope line
        const inlineComment = this.extractInlineComment(originalLine);
        const comments: string[] = [];
        if (inlineComment) {
            comments.push(inlineComment);
        }
        
        this.currentLine++;

        const body: Statement[] = [];
        let closed = false;
        let pendingComments: string[] = [];
        const pendingCommentLines: number[] = [];

        while (this.currentLine < this.lines.length) {
            const originalBodyLine = this.lines[this.currentLine];
            const bodyLine = originalBodyLine.trim();
            
            // Blank line: preserve pending comments (they may be attached to next statement)
            if (!bodyLine) {
                this.currentLine++;
                continue;
            }
            
            // Comment line: if we have pending comments, they were separated by blank line, so create comment nodes
            // Then start a new sequence with this comment
            if (bodyLine.startsWith('#')) {
                const commentText = bodyLine.slice(1).trim();
                
                // If we have pending comments, they were separated by blank line from this comment
                // Create comment nodes for them (they won't be attached to a statement)
                // Group consecutive orphaned comments into a single node
                if (pendingComments.length > 0) {
                    body.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                
                // Start new sequence with this comment
                pendingComments.push(commentText);
                pendingCommentLines.push(this.currentLine);
                this.currentLine++;
                continue;
            }

            const bodyTokens = Lexer.tokenize(bodyLine);
            
            if (bodyTokens[0] === 'endscope') {
                this.currentLine++;
                closed = true;
                break;
            }

            const stmt = this.parseStatement();
            if (stmt) {
                const allComments: string[] = [];
                
                // Consecutive comments above
                if (pendingComments.length > 0) {
                    allComments.push(...pendingComments);
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                
                // Inline comment on same line
                const inlineComment = this.extractInlineComment(originalBodyLine);
                if (inlineComment) {
                    allComments.push(inlineComment);
                }
                
                if (allComments.length > 0) {
                    (stmt as any).comments = allComments;
                }
                
                body.push(stmt);
            }
        }

        // Handle any remaining pending comments at end of block
        // Group consecutive orphaned comments into a single node
        if (pendingComments.length > 0) {
            body.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
        }

        if (!closed) {
            throw this.createError('missing endscope', this.currentLine);
        }

        // If parameters are declared, include them in the scope block
        const result: ScopeBlock = paramNames.length > 0 
            ? { type: 'scope', paramNames, body }
            : { type: 'scope', body };
        if (comments.length > 0) {
            result.comments = comments;
        }
        return result;
    }

    private parseForLoop(): ForLoop {
        const originalLine = this.lines[this.currentLine];
        const line = originalLine.trim();
        const tokens = Lexer.tokenize(line);
        
        // Parse: for $var in <expr>
        if (tokens.length < 4) {
            throw this.createError('for loop requires: for $var in <expr>', this.currentLine);
        }
        
        if (tokens[0] !== 'for') {
            throw this.createError('expected for keyword', this.currentLine);
        }
        
        // Get loop variable
        if (!LexerUtils.isVariable(tokens[1])) {
            throw this.createError('for loop variable must be a variable (e.g., $i, $item)', this.currentLine);
        }
        const varName = tokens[1].slice(1); // Remove $
        
        if (tokens[2] !== 'in') {
            throw this.createError("for loop requires 'in' keyword", this.currentLine);
        }
        
        // Get iterable expression (everything after 'in')
        const exprTokens = tokens.slice(3);
        const iterableExpr = exprTokens.join(' ');
        
        // Extract inline comment from for line
        const inlineComment = this.extractInlineComment(originalLine);
        const comments: string[] = [];
        if (inlineComment) {
            comments.push(inlineComment);
        }
        
        this.currentLine++;

        const body: Statement[] = [];
        let closed = false;
        let pendingComments: string[] = [];
        const pendingCommentLines: number[] = [];

        while (this.currentLine < this.lines.length) {
            const originalBodyLine = this.lines[this.currentLine];
            const bodyLine = originalBodyLine.trim();
            
            // Blank line: preserve pending comments (they may be attached to next statement)
            if (!bodyLine) {
                this.currentLine++;
                continue;
            }
            
            // Comment line: if we have pending comments, they were separated by blank line, so create comment nodes
            // Then start a new sequence with this comment
            if (bodyLine.startsWith('#')) {
                const commentText = bodyLine.slice(1).trim();
                
                // If we have pending comments, they were separated by blank line from this comment
                // Create comment nodes for them (they won't be attached to a statement)
                // Group consecutive orphaned comments into a single node
                if (pendingComments.length > 0) {
                    body.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                
                // Start new sequence with this comment
                pendingComments.push(commentText);
                pendingCommentLines.push(this.currentLine);
                this.currentLine++;
                continue;
            }

            const bodyTokens = Lexer.tokenize(bodyLine);
            
            if (bodyTokens[0] === 'endfor') {
                this.currentLine++;
                closed = true;
                break;
            }

            const stmt = this.parseStatement();
            if (stmt) {
                const allComments: string[] = [];
                
                // Consecutive comments above
                if (pendingComments.length > 0) {
                    allComments.push(...pendingComments);
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                
                // Inline comment on same line
                const inlineComment = this.extractInlineComment(originalBodyLine);
                if (inlineComment) {
                    allComments.push(inlineComment);
                }
                
                if (allComments.length > 0) {
                    (stmt as any).comments = allComments;
                }
                
                body.push(stmt);
            }
        }

        // Handle any remaining pending comments at end of block
        // Group consecutive orphaned comments into a single node
        if (pendingComments.length > 0) {
            body.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
        }

        if (!closed) {
            throw this.createError('missing endfor', this.currentLine);
        }

        const result: ForLoop = { type: 'forLoop', varName, iterableExpr, body };
        if (comments.length > 0) {
            result.comments = comments;
        }
        return result;
    }

    private parseReturn(): ReturnStatement {
        const line = this.lines[this.currentLine].trim();
        const tokens = Lexer.tokenize(line);
        
        this.currentLine++;
        
        // If there's a value after "return", parse it as an argument
        if (tokens.length > 1) {
            const valueTokens = tokens.slice(1);
            // Parse the value as a single argument
            const arg = this.parseReturnValue(valueTokens);
            return { type: 'return', value: arg };
        }
        
        // No value specified - returns $ (last value)
        return { type: 'return' };
    }

    private parseReturnValue(tokens: string[]): Arg {
        if (tokens.length === 0) {
            return { type: 'lastValue' };
        }
        
        const line = this.lines[this.currentLine - 1]; // Get the original line
        const returnIndex = line.indexOf('return');
        
        // Find the position after "return" in the original line
        const afterReturnStart = returnIndex + 6; // "return" is 6 chars
        let pos = afterReturnStart;
        
        // Skip whitespace after "return"
        while (pos < line.length && /\s/.test(line[pos])) {
            pos++;
        }
        
        // Check if we're at a $( subexpression
        if (pos < line.length - 1 && line[pos] === '$' && line[pos + 1] === '(') {
            const subexprCode = this.extractSubexpression(line, pos);
            return { type: 'subexpr', code: subexprCode.code };
        }
        
        // Otherwise, parse the first token
        const token = tokens[0].trim(); // Ensure token is trimmed
        
        // Check if it's exactly $ (last value without attributes)
        if (token === '$') {
            return { type: 'lastValue' };
        } else if (LexerUtils.isVariable(token)) {
            // This includes $.property, $[index], $var, $var.property, etc.
            const { name, path } = LexerUtils.parseVariablePath(token);
            // If name is empty, it means last value with attributes (e.g., $.name)
            if (name === '') {
                return { type: 'var', name: '', path };
            }
            return { type: 'var', name, path };
        } else if (token === 'true') {
            return { type: 'literal', value: true };
        } else if (token === 'false') {
            return { type: 'literal', value: false };
        } else if (token === 'null') {
            return { type: 'literal', value: null };
        } else if (LexerUtils.isPositionalParam(token)) {
            return { type: 'var', name: token.slice(1) };
        } else if (LexerUtils.isString(token)) {
            return { type: 'string', value: LexerUtils.parseString(token) };
        } else if (LexerUtils.isNumber(token)) {
            return { type: 'number', value: parseFloat(token) };
        } else {
            // Treat as literal
            return { type: 'literal', value: token };
        }
    }

    private parseIfBlock(): IfBlock {
        const originalLine = this.lines[this.currentLine];
        const line = originalLine.trim();
        
        // Extract condition (everything after 'if')
        // Use the original line string to preserve subexpressions $(...)
        const ifIndex = line.indexOf('if');
        if (ifIndex === -1) {
            throw this.createError('if statement must start with "if"', this.currentLine);
        }
        // Find the position after "if" and any whitespace
        let conditionStart = ifIndex + 2; // "if" is 2 characters
        while (conditionStart < line.length && /\s/.test(line[conditionStart])) {
            conditionStart++;
        }
        const conditionExpr = line.slice(conditionStart).trim();

        // Extract inline comment from if line
        const inlineComment = this.extractInlineComment(originalLine);
        const comments: string[] = [];
        if (inlineComment) {
            comments.push(inlineComment);
        }

        this.currentLine++;

        const thenBranch: Statement[] = [];
        const elseifBranches: Array<{ condition: string; body: Statement[] }> = [];
        let elseBranch: Statement[] | undefined;
        let currentBranch: Statement[] = thenBranch;
        let pendingComments: string[] = [];
        const pendingCommentLines: number[] = [];
        let hasBlankLineAfterLastComment = false;
        let hasCreatedCommentNodes = false;
        let closed = false;

        while (this.currentLine < this.lines.length) {
            const originalBodyLine = this.lines[this.currentLine];
            const bodyLine = originalBodyLine.trim();
            
            // Blank line: mark that blank line appeared after last comment
            if (!bodyLine) {
                hasBlankLineAfterLastComment = true;
                this.currentLine++;
                continue;
            }
            
            // Comment line: if we have pending comments with blank line after, create comment nodes
            if (bodyLine.startsWith('#')) {
                const commentText = bodyLine.slice(1).trim();
                
                // If we have pending comments and there was a blank line after them, create comment nodes
                if (pendingComments.length > 0 && hasBlankLineAfterLastComment) {
                    // Group consecutive orphaned comments into a single node
                    currentBranch.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                    hasCreatedCommentNodes = true;
                } else if (!hasBlankLineAfterLastComment) {
                    // Consecutive comment (no blank line) - reset flag so they can be attached
                    hasCreatedCommentNodes = false;
                }
                
                // Start new sequence with this comment
                pendingComments.push(commentText);
                pendingCommentLines.push(this.currentLine);
                hasBlankLineAfterLastComment = false;
                this.currentLine++;
                continue;
            }

            const tokens = Lexer.tokenize(bodyLine);

            // Handle elseif - switch to new branch
            if (tokens[0] === 'elseif') {
                // Extract condition from original line string to preserve subexpressions $(...)
                const elseifIndex = bodyLine.indexOf('elseif');
                if (elseifIndex === -1) {
                    throw this.createError('elseif statement must contain "elseif"', this.currentLine);
                }
                // Find the position after "elseif" and any whitespace
                let conditionStart = elseifIndex + 6; // "elseif" is 6 characters
                while (conditionStart < bodyLine.length && /\s/.test(bodyLine[conditionStart])) {
                    conditionStart++;
                }
                const condition = bodyLine.slice(conditionStart).trim();
                
                // Extract inline comment from elseif line
                const elseifInlineComment = this.extractInlineComment(originalBodyLine);
                const elseifComments: string[] = [];
                if (pendingComments.length > 0) {
                    elseifComments.push(...pendingComments);
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                if (elseifInlineComment) {
                    elseifComments.push(elseifInlineComment);
                }
                
                elseifBranches.push({ condition, body: [] });
                currentBranch = elseifBranches[elseifBranches.length - 1].body;
                hasBlankLineAfterLastComment = false;
                hasCreatedCommentNodes = false;
                this.currentLine++;
                continue;
            }

            // Handle else - switch to else branch
            if (tokens[0] === 'else') {
                // Extract inline comment from else line
                const elseInlineComment = this.extractInlineComment(originalBodyLine);
                const elseComments: string[] = [];
                if (pendingComments.length > 0) {
                    elseComments.push(...pendingComments);
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                if (elseInlineComment) {
                    elseComments.push(elseInlineComment);
                }
                
                elseBranch = [];
                currentBranch = elseBranch;
                hasBlankLineAfterLastComment = false;
                hasCreatedCommentNodes = false;
                this.currentLine++;
                continue;
            }

            // If this is our closing endif, consume it and stop
            if (tokens[0] === 'endif') {
                this.currentLine++;
                closed = true;
                break;
            }

            const stmt = this.parseStatement();
            if (stmt) {
                const allComments: string[] = [];
                
                // If we've created comment nodes before, remaining comments should also be nodes
                if (pendingComments.length > 0 && hasCreatedCommentNodes) {
                    // Group consecutive orphaned comments into a single node
                    currentBranch.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                } else if (pendingComments.length > 0) {
                    // No comment nodes created - attach comments
                    allComments.push(...pendingComments);
                    pendingComments.length = 0;
                    pendingCommentLines.length = 0;
                }
                
                // Inline comment on same line
                const inlineComment = this.extractInlineComment(originalBodyLine);
                if (inlineComment) {
                    allComments.push(inlineComment);
                }
                
                if (allComments.length > 0) {
                    (stmt as any).comments = allComments;
                }
                
                currentBranch.push(stmt);
                hasBlankLineAfterLastComment = false;
                hasCreatedCommentNodes = false;
            }
        }

        // Handle any remaining pending comments at end of block
        // Group consecutive orphaned comments into a single node
        if (pendingComments.length > 0) {
            currentBranch.push(this.createGroupedCommentNode(pendingComments, pendingCommentLines));
        }

        if (!closed) {
            throw this.createError('missing endif', this.currentLine);
        }

        const result: IfBlock = {
            type: 'ifBlock',
            conditionExpr,
            thenBranch,
            elseifBranches: elseifBranches.length > 0 ? elseifBranches : undefined,
            elseBranch
        };
        if (comments.length > 0) {
            result.comments = comments;
        }
        return result;
    }

    private parseInlineIf(): InlineIf {
        const originalLine = this.lines[this.currentLine];
        const line = originalLine.trim();
        const tokens = Lexer.tokenize(line);
        
        const thenIndex = tokens.indexOf('then');
        if (thenIndex === -1) {
            throw this.createError("inline if requires 'then'", this.currentLine);
        }

        const conditionTokens = tokens.slice(1, thenIndex);
        const conditionExpr = conditionTokens.join(' ');
        
        const commandTokens = tokens.slice(thenIndex + 1);
        
        // Check if this is an assignment FIRST, before trying to parse as command
        let finalCommand: Statement;
        if (commandTokens.length >= 3 && LexerUtils.isVariable(commandTokens[0]) && commandTokens[1] === '=') {
            // This is an assignment - parse target with possible attribute path
            const targetVar = commandTokens[0];
            const { name: targetName, path: targetPath } = LexerUtils.parseVariablePath(targetVar);
            const restTokens = commandTokens.slice(2);
            
            // Check if it's a literal value
            if (restTokens.length === 1) {
                const token = restTokens[0];
                if (LexerUtils.isNumber(token)) {
                    finalCommand = { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: parseFloat(token) 
                    };
                } else if (LexerUtils.isString(token)) {
                    finalCommand = { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: LexerUtils.parseString(token) 
                    };
                } else if (token === 'true') {
                    finalCommand = { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: true 
                    };
                } else if (token === 'false') {
                    finalCommand = { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: false 
                    };
                } else if (token === 'null') {
                    finalCommand = { 
                        type: 'assignment', 
                        targetName, 
                        targetPath,
                        literalValue: null 
                    };
                } else {
                    const cmd = this.parseCommandFromTokens(restTokens);
                    finalCommand = { type: 'assignment', targetName, targetPath, command: cmd };
                }
            } else {
                const cmd = this.parseCommandFromTokens(restTokens);
                finalCommand = { type: 'assignment', targetName, targetPath, command: cmd };
            }
        } else {
            // Check if it's a break or return statement
            if (commandTokens.length === 1 && commandTokens[0] === 'break') {
                finalCommand = { type: 'break' };
            } else if (commandTokens.length >= 1 && commandTokens[0] === 'return') {
                // Parse return statement
                const returnValueTokens = commandTokens.slice(1);
                if (returnValueTokens.length === 0) {
                    finalCommand = { type: 'return' };
                } else {
                    const returnValue = this.parseReturnValue(returnValueTokens);
                    finalCommand = { type: 'return', value: returnValue };
            }
        } else {
            // Not an assignment, parse as regular command
            finalCommand = this.parseCommandFromTokens(commandTokens);
            }
        }

        // Extract inline comment from inline if line
        const inlineComment = this.extractInlineComment(originalLine);
        const comments: string[] = [];
        if (inlineComment) {
            comments.push(inlineComment);
        }

        this.currentLine++;
        const result: InlineIf = { type: 'inlineIf', conditionExpr, command: finalCommand };
        if (comments.length > 0) {
            result.comments = comments;
        }
        return result;
    }

    private parseCommandFromTokens(tokens: string[]): CommandCall {
        if (tokens.length === 0) {
            throw this.createError('empty command', this.currentLine);
        }

        // Handle module function calls: math.add -> tokens: ["math", ".", "add"]
        // Combine module name and function name if second token is "."
        let name: string;
        let argStartIndex = 1;
        if (tokens.length >= 3 && tokens[1] === '.') {
            // Validate module name doesn't start with a number
            if (/^\d/.test(tokens[0])) {
                throw this.createError(`module name cannot start with a number: ${tokens[0]}`, this.currentLine);
            }
            // Validate function name doesn't start with a number
            if (/^\d/.test(tokens[2])) {
                throw this.createError(`function name cannot start with a number: ${tokens[2]}`, this.currentLine);
            }
            name = `${tokens[0]}.${tokens[2]}`;
            argStartIndex = 3;
        } else {
            name = tokens[0];
            // Validate function name doesn't start with a number
            if (/^\d/.test(name)) {
                throw this.createError(`function name cannot start with a number: ${name}`, this.currentLine);
            }
        }
        
        // Validate that the first token is not a literal number, string, variable, or last value reference
        // (strings should be quoted, numbers should not be command names, variables are not commands, $ is not a command)
        if (LexerUtils.isNumber(name)) {
            throw this.createError(`expected command name, got number: ${name}`, this.currentLine);
        }
        if (LexerUtils.isString(name)) {
            throw this.createError(`expected command name, got string literal: ${name}`, this.currentLine);
        }
        if (LexerUtils.isVariable(name) || LexerUtils.isPositionalParam(name)) {
            throw this.createError(`expected command name, got variable: ${name}`, this.currentLine);
        }
        if (LexerUtils.isLastValue(name)) {
            throw this.createError(`expected command name, got last value reference: ${name}`, this.currentLine);
        }
        
        const positionalArgs: Arg[] = [];
        const namedArgs: Record<string, Arg> = {};
        let currentLineIndex = this.currentLine;
        let line = this.lines[currentLineIndex];

        // We need to scan the original line to find $(...) subexpressions
        // because tokenization may have split them incorrectly
        let i = argStartIndex;
        
        // Find the position after the command name in the original line
        // For module functions like "math.add", we need to find the position after the full name
        let nameEndPos: number;
        if (argStartIndex === 3) {
            // Module function: tokens[0] + "." + tokens[2]
            // Find where tokens[0] starts, then calculate end position
            const moduleToken = tokens[0];
            const modulePos = line.indexOf(moduleToken);
            // Calculate end: module name + "." + function name
            nameEndPos = modulePos + moduleToken.length + 1 + tokens[2].length;
        } else {
            // Regular function: just tokens[0]
            nameEndPos = line.indexOf(name) + name.length;
        }
        let pos = nameEndPos;
        
        // Skip whitespace after command name
        while (pos < line.length && /\s/.test(line[pos])) {
            pos++;
        }

        while (i < tokens.length || pos < line.length || currentLineIndex < this.lines.length) {
            // Update line if we've moved to a new line
            if (currentLineIndex !== this.currentLine) {
                currentLineIndex = this.currentLine;
                line = this.lines[currentLineIndex];
                pos = 0;
                // Skip whitespace at start of new line
                while (pos < line.length && /\s/.test(line[pos])) {
                    pos++;
                }
            }
            
            // Check if we're at a $( subexpression in the current line
            if (pos < line.length - 1 && line[pos] === '$' && line[pos + 1] === '(') {
                // Extract the subexpression code
                const subexprCode = this.extractSubexpression(line, pos);
                positionalArgs.push({ type: 'subexpr', code: subexprCode.code });
                
                // Skip past the $() in the current line
                pos = subexprCode.endPos;
                
                // Skip any tokens that were part of this subexpression
                // We'll skip tokens until we find one that starts after our end position
                while (i < tokens.length) {
                    const tokenStart = line.indexOf(tokens[i], pos - 100); // Search from a bit before
                    if (tokenStart === -1 || tokenStart >= pos) {
                        break;
                    }
                    i++;
                }
                
                // Skip whitespace
                while (pos < line.length && /\s/.test(line[pos])) {
                    pos++;
                }
                continue;
            }

            // Check if we're at an object literal { ... }
            if (pos < line.length && line[pos] === '{') {
                const startLineIndex = this.currentLine;
                const objCode = this.extractObjectLiteral(line, pos);
                positionalArgs.push({ type: 'object', code: objCode.code });
                
                // extractObjectLiteral may have advanced this.currentLine if it was multi-line
                // Update our tracking variables
                if (this.currentLine > startLineIndex) {
                    // We've moved to a new line - continue parsing from that line
                    currentLineIndex = this.currentLine;
                    line = this.lines[currentLineIndex];
                    pos = objCode.endPos;
                    // Skip past the closing brace
                    if (pos < line.length && line[pos] === '}') {
                        pos++;
                    }
                    // Re-tokenize the remaining part of this line to get any remaining arguments
                    const remainingLine = line.substring(pos).trim();
                    if (remainingLine) {
                        const remainingTokens = Lexer.tokenize(remainingLine);
                        // Insert remaining tokens at current position
                        tokens.splice(i, 0, ...remainingTokens);
                    }
                } else {
                    pos = objCode.endPos;
                }
                
                // Skip any tokens that were part of this object
                while (i < tokens.length) {
                    const tokenStart = line.indexOf(tokens[i], Math.max(0, pos - 100));
                    if (tokenStart === -1 || tokenStart >= pos) {
                        break;
                    }
                    i++;
                }
                
                // Skip whitespace
                while (pos < line.length && /\s/.test(line[pos])) {
                    pos++;
                }
                continue;
            }

            // Check if we're at an array literal [ ... ]
            if (pos < line.length && line[pos] === '[') {
                const startLineIndex = this.currentLine;
                const arrCode = this.extractArrayLiteral(line, pos);
                positionalArgs.push({ type: 'array', code: arrCode.code });
                
                // extractArrayLiteral may have advanced this.currentLine if it was multi-line
                // Update our tracking variables
                if (this.currentLine > startLineIndex) {
                    // We've moved to a new line - continue parsing from that line
                    currentLineIndex = this.currentLine;
                    line = this.lines[currentLineIndex];
                    pos = arrCode.endPos;
                    // Skip past the closing bracket
                    if (pos < line.length && line[pos] === ']') {
                        pos++;
                    }
                    // Re-tokenize the remaining part of this line to get any remaining arguments
                    const remainingLine = line.substring(pos).trim();
                    if (remainingLine) {
                        const remainingTokens = Lexer.tokenize(remainingLine);
                        // Insert remaining tokens at current position
                        tokens.splice(i, 0, ...remainingTokens);
                    }
                } else {
                    pos = arrCode.endPos;
                }
                
                // Skip any tokens that were part of this array
                while (i < tokens.length) {
                    const tokenStart = line.indexOf(tokens[i], Math.max(0, pos - 100));
                    if (tokenStart === -1 || tokenStart >= pos) {
                        break;
                    }
                    i++;
                }
                
                // Skip whitespace
                while (pos < line.length && /\s/.test(line[pos])) {
                    pos++;
                }
                continue;
            }
            
            // If we've processed all tokens and we're at the end of the current line,
            // check if there are more lines to process (for multi-line commands)
            if (i >= tokens.length && pos >= line.length) {
                // Check if we've moved to a new line due to multi-line literal extraction
                if (currentLineIndex < this.currentLine) {
                    // We've moved ahead, continue from the new line
                    currentLineIndex = this.currentLine;
                    line = this.lines[currentLineIndex];
                    pos = 0;
                    // Re-tokenize the new line to get remaining arguments
                    const remainingTokens = Lexer.tokenize(line);
                    // Add remaining tokens to our processing queue
                    tokens.push(...remainingTokens);
                    // Skip whitespace
                    while (pos < line.length && /\s/.test(line[pos])) {
                        pos++;
                    }
                    continue;
                } else {
                    // No more lines to process
                    break;
                }
            }
            
            // If we've processed all tokens from the original line but there's more content on current line
            if (i >= tokens.length && pos < line.length) {
                // Re-tokenize remaining part of current line
                const remainingLine = line.substring(pos).trim();
                if (remainingLine) {
                    const remainingTokens = Lexer.tokenize(remainingLine);
                    tokens.push(...remainingTokens);
                    // Update pos to end of line to avoid re-processing
                    pos = line.length;
                }
            }
            
            // If we still have no tokens, break
            if (i >= tokens.length) {
                break;
            }
            
            const token = tokens[i];
            
            // Check if this is a named argument: key=value
            const equalsIndex = token.indexOf('=');
            if (equalsIndex > 0 && equalsIndex < token.length - 1 && 
                !token.startsWith('"') && !token.startsWith("'") && !token.startsWith('`')) {
                const key = token.substring(0, equalsIndex).trim();
                const valueStr = token.substring(equalsIndex + 1).trim();
                
                // Validate key name (must be identifier-like)
                if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(key)) {
                    // This is a named argument: key=value
                    const valueArg = this.parseArgumentValue(valueStr);
                    namedArgs[key] = valueArg;
                    
                    // Advance position
                    const tokenPos = line.indexOf(token, pos);
                    if (tokenPos !== -1) {
                        pos = tokenPos + token.length;
                        while (pos < line.length && /\s/.test(line[pos])) {
                            pos++;
                        }
                    }
                    i++;
                    continue;
                }
            }
            
            // Parse as positional argument
            let arg: Arg;
            if (token === '$') {
                arg = { type: 'lastValue' };
            } else if (LexerUtils.isVariable(token)) {
                // This includes $.property, $[index], $var, $var.property, etc.
                const { name: varName, path } = LexerUtils.parseVariablePath(token);
                arg = { type: 'var', name: varName, path };
            } else if (token === 'true') {
                arg = { type: 'literal', value: true };
            } else if (token === 'false') {
                arg = { type: 'literal', value: false };
            } else if (token === 'null') {
                arg = { type: 'literal', value: null };
            } else if (LexerUtils.isPositionalParam(token)) {
                arg = { type: 'var', name: token.slice(1) };
            } else if (LexerUtils.isString(token)) {
                arg = { type: 'string', value: LexerUtils.parseString(token) };
            } else if (LexerUtils.isNumber(token)) {
                arg = { type: 'number', value: parseFloat(token) };
            } else {
                // Treat as literal string
                arg = { type: 'literal', value: token };
            }
            
            positionalArgs.push(arg);
            
            // Advance position in line (approximate)
            const tokenPos = line.indexOf(token, pos);
            if (tokenPos !== -1) {
                pos = tokenPos + token.length;
                while (pos < line.length && /\s/.test(line[pos])) {
                    pos++;
                }
            }
            
            i++;
        }

        // Combine positional args and named args (named args as a special object)
        const args: Arg[] = [...positionalArgs];
        if (Object.keys(namedArgs).length > 0) {
            args.push({ type: 'namedArgs', args: namedArgs });
        }

        return { type: 'command', name, args };
    }

    /**
     * Extract a $(...) subexpression from a line, starting at the given position.
     * Returns the inner code and the end position.
     * Handles multi-line subexpressions (newlines are preserved in the code).
     */
    private extractSubexpression(line: string, startPos: number): { code: string; endPos: number } {
        // Skip past "$("
        let pos = startPos + 2;
        let depth = 1;
        let inString: false | '"' | "'" | '`' = false;
        const code: string[] = [];
        
        while (pos < line.length && depth > 0) {
            const char = line[pos];
            const prevChar = pos > 0 ? line[pos - 1] : '';
            
            // Handle strings
            if ((char === '"' || char === "'" || char === '`') && prevChar !== '\\') {
                if (!inString) {
                    inString = char;
                } else if (char === inString) {
                    inString = false;
                }
                code.push(char);
                pos++;
                continue;
            }
            
            if (inString) {
                code.push(char);
                pos++;
                continue;
            }
            
            // Handle nested $() subexpressions
            if (char === '$' && pos + 1 < line.length && line[pos + 1] === '(') {
                depth++;
                code.push(char);
                pos++;
                continue;
            }
            
            if (char === ')') {
                depth--;
                if (depth > 0) {
                    // This is a closing paren for a nested subexpr
                    code.push(char);
                }
                // If depth === 0, we're done - don't include this closing paren
                pos++;
                continue;
            }
            
            // Preserve all characters including newlines, spaces, tabs, etc.
            code.push(char);
            pos++;
        }
        
        // If we exited because we reached the end of the line but depth > 0,
        // that means the subexpression spans multiple lines (which should be handled by splitIntoLogicalLines)
        // But if it somehow didn't, we should still return what we have
        if (depth > 0 && pos >= line.length) {
            // This shouldn't happen if splitIntoLogicalLines is working correctly,
            // but we'll handle it gracefully
            throw this.createError(`unclosed subexpression starting at position ${startPos}`, this.currentLine);
        }
        
        return {
            code: code.join(''),
            endPos: pos
        };
    }

    /**
     * Extract object literal { ... } from a line, starting at the given position.
     * Handles nested objects, arrays, and strings.
     * Supports multi-line objects.
     */
    private extractObjectLiteral(line: string, startPos: number): { code: string; endPos: number } {
        // Skip past "{"
        let pos = startPos + 1;
        let braceDepth = 1;
        let bracketDepth = 0; // Track array depth inside object
        let inString: false | '"' | "'" | '`' = false;
        const code: string[] = [];
        let currentLineIndex = this.currentLine;
        
        while (currentLineIndex < this.lines.length && braceDepth > 0) {
            const currentLine = currentLineIndex === this.currentLine ? line : this.lines[currentLineIndex];
            
            while (pos < currentLine.length && braceDepth > 0) {
                const char = currentLine[pos];
                const prevChar = pos > 0 ? currentLine[pos - 1] : '';
                
                // Handle strings
                if ((char === '"' || char === "'" || char === '`') && prevChar !== '\\') {
                    if (!inString) {
                        inString = char;
                    } else if (char === inString) {
                        inString = false;
                    }
                    code.push(char);
                    pos++;
                    continue;
                }
                
                if (inString) {
                    code.push(char);
                    pos++;
                    continue;
                }
                
                // Handle nested objects and arrays
                if (char === '{') {
                    braceDepth++;
                    code.push(char);
                } else if (char === '}') {
                    braceDepth--;
                    if (braceDepth > 0) {
                        code.push(char);
                    }
                    // If braceDepth === 0, we're done - don't include this closing brace
                } else if (char === '[') {
                    bracketDepth++;
                    code.push(char);
                } else if (char === ']') {
                    bracketDepth--;
                    code.push(char);
                } else {
                    code.push(char);
                }
                pos++;
            }
            
            if (braceDepth > 0) {
                // Need to continue on next line
                code.push('\n');
                currentLineIndex++;
                pos = 0;
            }
        }
        
        if (braceDepth > 0) {
            throw this.createError('unclosed object literal', this.currentLine);
        }
        
        // Update currentLine if we moved to a new line
        if (currentLineIndex > this.currentLine) {
            this.currentLine = currentLineIndex;
        }
        
        return {
            code: code.join('').trim(),
            endPos: pos
        };
    }

    /**
     * Extract array literal [ ... ] from a line, starting at the given position.
     * Handles nested arrays, objects, and strings.
     * Supports multi-line arrays.
     */
    private extractArrayLiteral(line: string, startPos: number): { code: string; endPos: number } {
        // Skip past "["
        let pos = startPos + 1;
        let bracketDepth = 1;
        let braceDepth = 0; // Track object depth inside array
        let inString: false | '"' | "'" | '`' = false;
        const code: string[] = [];
        let currentLineIndex = this.currentLine;
        
        while (currentLineIndex < this.lines.length && bracketDepth > 0) {
            const currentLine = currentLineIndex === this.currentLine ? line : this.lines[currentLineIndex];
            
            while (pos < currentLine.length && bracketDepth > 0) {
                const char = currentLine[pos];
                const prevChar = pos > 0 ? currentLine[pos - 1] : '';
                
                // Handle strings
                if ((char === '"' || char === "'" || char === '`') && prevChar !== '\\') {
                    if (!inString) {
                        inString = char;
                    } else if (char === inString) {
                        inString = false;
                    }
                    code.push(char);
                    pos++;
                    continue;
                }
                
                if (inString) {
                    code.push(char);
                    pos++;
                    continue;
                }
                
                // Handle nested arrays and objects
                if (char === '[') {
                    bracketDepth++;
                    code.push(char);
                } else if (char === ']') {
                    bracketDepth--;
                    if (bracketDepth > 0) {
                        code.push(char);
                    }
                    // If bracketDepth === 0, we're done - don't include this closing bracket
                } else if (char === '{') {
                    braceDepth++;
                    code.push(char);
                } else if (char === '}') {
                    braceDepth--;
                    code.push(char);
                } else {
                    code.push(char);
                }
                pos++;
            }
            
            if (bracketDepth > 0) {
                // Need to continue on next line
                code.push('\n');
                currentLineIndex++;
                pos = 0;
            }
        }
        
        if (bracketDepth > 0) {
            throw this.createError('unclosed array literal', this.currentLine);
        }
        
        // Update currentLine if we moved to a new line
        if (currentLineIndex > this.currentLine) {
            this.currentLine = currentLineIndex;
        }
        
        return {
            code: code.join('').trim(),
            endPos: pos
        };
    }
}

// ============================================================================
// Expression Evaluator
// ============================================================================

// ExpressionEvaluator is imported from classes

// ============================================================================
// Executor
// ============================================================================

// Exceptions and Executor are imported from classes

// ============================================================================
// Execution State Tracker
// ============================================================================

// ExecutionStateTracker is imported from classes

// ============================================================================
// RobinPath Thread
// ============================================================================

// RobinPathThread is imported from classes
    private environment: Environment;
    private executor: Executor;
    public readonly id: string;
    private parent: RobinPath | null = null;

    constructor(baseEnvironment: Environment, id: string, parent?: RobinPath) {
            moduleMetadata: new Map(),
            currentModule: null,
            variableMetadata: new Map(),
            functionMetadata: new Map()
        };

        // Create persistent executor for REPL mode
        this.persistentExecutor = new Executor(this.environment, null);

        // Load native modules (includes Core module with built-in functions)
        this.loadNativeModules();

        // Note: "use" command is handled specially in executeCommand to access the executor's environment

        this.registerBuiltin('explain', (args) => {
            const nameArg = args[0];
            if (!nameArg) {
                const errorMsg = 'Error: explain requires a module or function name';
                console.log(errorMsg);
                return errorMsg;
            }
            
            // Convert to string (handles both quoted strings and unquoted literals)
            const name = String(nameArg);

            // Check if it's a module name (no dot) or module.function (has dot)
            if (name.includes('.')) {
                // It's a module.function - show function metadata
                const functionMetadata = this.environment.metadata.get(name);
                if (!functionMetadata) {
                    const errorMsg = `No documentation available for function: ${name}`;
                    console.log(errorMsg);
                    return errorMsg;
                }

                // Format the function metadata as a readable string
                let result = `Function: ${name}\n\n`;
                result += `Description: ${functionMetadata.description}\n\n`;

                if (functionMetadata.parameters && functionMetadata.parameters.length > 0) {
                    result += `Parameters:\n`;
                    for (const param of functionMetadata.parameters) {
                        result += `  - ${param.name} (${param.dataType})`;
                        if (param.required) {
                            result += ' [required]';
                        }
                        result += `\n    ${param.description}`;
                        if (param.formInputType) {
                            result += `\n    Input type: ${param.formInputType}`;
                        }
                        if (param.defaultValue !== undefined) {
                            result += `\n    Default: ${JSON.stringify(param.defaultValue)}`;
                        }
                        result += '\n';
                    }
                } else {
                    result += `Parameters: None\n`;
                }

                result += `\nReturns: ${functionMetadata.returnType}`;
                if (functionMetadata.returnDescription) {
                    result += `\n  ${functionMetadata.returnDescription}`;
                }

                if (functionMetadata.example) {
                    result += `\n\nExample:\n  ${functionMetadata.example}`;
                }

                // Automatically print the result
                console.log(result);
                return result;
            } else {
                // It's a module name - show module metadata
                const moduleMetadata = this.environment.moduleMetadata.get(name);
                if (!moduleMetadata) {
                    const errorMsg = `No documentation available for module: ${name}`;
                    console.log(errorMsg);
                    return errorMsg;
                }

                // Format the module metadata as a readable string
                let result = `Module: ${name}\n\n`;
                result += `Description: ${moduleMetadata.description}\n\n`;
                
                if (moduleMetadata.methods && moduleMetadata.methods.length > 0) {
                    result += `Available Methods:\n`;
                    for (const method of moduleMetadata.methods) {
                        result += `  - ${method}\n`;
                    }
                } else {
                    result += `Available Methods: None\n`;
                }

                // Automatically print the result
                console.log(result);
                return result;
            }
        });
    }

    /**
     * Native modules registry
     * Add new modules here to auto-load them
     */
    private static readonly NATIVE_MODULES: ModuleAdapter[] = [
        CoreModule,
        MathModule,
        StringModule,
        JsonModule,
        ObjectModule,
        TimeModule,
        RandomModule,
        ArrayModule,
        FetchModule,
        TestModule
    ];

    /**
     * Load a single module using the adapter pattern
     */
    private loadModule(module: ModuleAdapter): void {
        // Register all module functions
        this.registerModule(module.name, module.functions);
        
        // Register function metadata
        this.registerModuleMeta(module.name, module.functionMetadata);
        
        // Register module-level metadata
        this.registerModuleInfo(module.name, module.moduleMetadata);
        
        // If global is true, also register functions as builtins (without module prefix)
        // This allows calling them directly: add 5 5 instead of math.add 5 5
        if (module.global === true) {
            for (const [funcName, funcHandler] of Object.entries(module.functions)) {
                // Only register if not already registered (avoid conflicts with existing builtins)
                if (!this.environment.builtins.has(funcName)) {
                    this.environment.builtins.set(funcName, funcHandler);
                }
            }
        }
    }

    /**
     * Load all native modules
     */
    private loadNativeModules(): void {
        for (const module of RobinPath.NATIVE_MODULES) {
            this.loadModule(module);
        }
    }

    /**
     * Register a builtin function
     */
    registerBuiltin(name: string, handler: BuiltinHandler): void {
        this.environment.builtins.set(name, handler);
    }

    /**
     * Register a module with multiple functions
     * @example
     * rp.registerModule('fs', {
     *   read: (args) => { ... },
     *   write: (args) => { ... }
     * });
     */
    registerModule(moduleName: string, functions: Record<string, BuiltinHandler>): void {
        for (const [funcName, handler] of Object.entries(functions)) {
            this.environment.builtins.set(`${moduleName}.${funcName}`, handler);
        }
    }

    /**
     * Register a module function (e.g., 'fs.read')
     */
    registerModuleFunction(module: string, func: string, handler: BuiltinHandler): void {
        this.environment.builtins.set(`${module}.${func}`, handler);
    }

    /**
     * Register an external class constructor (e.g., 'Client', 'Database')
     */
    registerConstructor(name: string, handler: BuiltinHandler): void {
        this.environment.builtins.set(name, handler);
    }

    /**
     * Register metadata for a module with multiple functions
     * @example
     * rp.registerModuleMeta('fs', {
     *   read: {
     *     description: 'Reads a file from the filesystem',
     *     parameters: [
     *       {
     *         name: 'filename',
     *         dataType: 'string',
     *         description: 'Path to the file to read',
     *         formInputType: 'text',
     *         required: true
     *       }
     *     ],
     *     returnType: 'string',
     *     returnDescription: 'Contents of the file'
     *   },
     *   write: {
     *     description: 'Writes content to a file',
     *     parameters: [
     *       {
     *         name: 'filename',
     *         dataType: 'string',
     *         description: 'Path to the file to write',
     *         formInputType: 'text',
     *         required: true
     *       },
     *       {
     *         name: 'content',
     *         dataType: 'string',
     *         description: 'Content to write to the file',
     *         formInputType: 'textarea',
     *         required: true
     *       }
     *     ],
     *     returnType: 'boolean',
     *     returnDescription: 'True if write was successful'
     *   }
     * });
     */
    registerModuleMeta(moduleName: string, functions: Record<string, FunctionMetadata>): void {
        for (const [funcName, metadata] of Object.entries(functions)) {
            this.environment.metadata.set(`${moduleName}.${funcName}`, metadata);
        }
    }

    /**
     * Register metadata for a single module function (e.g., 'fs.read')
     * @example
     * rp.registerModuleFunctionMeta('fs', 'read', {
     *   description: 'Reads a file from the filesystem',
     *   parameters: [
     *     {
     *       name: 'filename',
     *       dataType: 'string',
     *       description: 'Path to the file to read',
     *       formInputType: 'text',
     *       required: true
     *     }
     *   ],
     *   returnType: 'string',
     *   returnDescription: 'Contents of the file'
     * });
     */
    registerModuleFunctionMeta(module: string, func: string, metadata: FunctionMetadata): void {
        this.environment.metadata.set(`${module}.${func}`, metadata);
    }

    /**
     * Get metadata for a function (builtin or module function)
     * Returns null if no metadata is registered
     */
    getFunctionMetadata(functionName: string): FunctionMetadata | null {
        return this.environment.metadata.get(functionName) ?? null;
    }

    /**
     * Get all registered function metadata
     */
    getAllFunctionMetadata(): Map<string, FunctionMetadata> {
        return new Map(this.environment.metadata);
    }

    /**
     * Register module-level metadata (description and list of methods)
     * @example
     * rp.registerModuleInfo('fs', {
     *   description: 'File system operations for reading and writing files',
     *   methods: ['read', 'write', 'exists', 'delete']
     * });
     */
    registerModuleInfo(moduleName: string, metadata: ModuleMetadata): void {
        this.environment.moduleMetadata.set(moduleName, metadata);
    }

    /**
     * Get module metadata (description and methods list)
     * Returns null if no metadata is registered
     */
    getModuleInfo(moduleName: string): ModuleMetadata | null {
        return this.environment.moduleMetadata.get(moduleName) ?? null;
    }

    /**
     * Get all registered module metadata
     */
    getAllModuleInfo(): Map<string, ModuleMetadata> {
        return new Map(this.environment.moduleMetadata);
    }

    /**
     * Get syntax context for available commands
     * Determines what commands are valid based on the current syntax position
     */
    private getSyntaxContext(context?: {
        inIfBlock?: boolean;
        inDefBlock?: boolean;
        afterIf?: boolean;
        afterDef?: boolean;
        afterElseif?: boolean;
    }): {
        canStartStatement: boolean;
        canUseBlockKeywords: boolean;
        canUseEndKeywords: boolean;
        canUseConditionalKeywords: boolean;
    } {
        const ctx = context || {};
        
        return {
            // Can start a new statement (commands, assignments, etc.)
            canStartStatement: !ctx.afterIf && !ctx.afterDef && !ctx.afterElseif,
            
            // Can use block keywords (if, def)
            canUseBlockKeywords: !ctx.inIfBlock && !ctx.inDefBlock,
            
            // Can use end keywords (endif, enddef)
            canUseEndKeywords: !!(ctx.inIfBlock || ctx.inDefBlock),
            
            // Can use conditional keywords (elseif, else)
            canUseConditionalKeywords: !!ctx.inIfBlock
        };
    }

    /**
     * Get all available commands, modules, and functions
     * Returns a structured object with categories, each containing objects with:
     * - name: The command/function name
     * - type: The type (native, builtin, module, moduleFunction, userFunction)
     * - description: Description if available
     * 
     * @param context Optional syntax context to filter commands based on what's valid next
     */
    getAvailableCommands(context?: {
        inIfBlock?: boolean;
        inDefBlock?: boolean;
        afterIf?: boolean;
        afterDef?: boolean;
        afterElseif?: boolean;
    }): {
        native: Array<{ name: string; type: string; description: string }>;
        builtin: Array<{ name: string; type: string; description: string }>;
        modules: Array<{ name: string; type: string; description: string }>;
        moduleFunctions: Array<{ name: string; type: string; description: string }>;
        userFunctions: Array<{ name: string; type: string; description: string }>;
    } {
        const syntaxCtx = this.getSyntaxContext(context);
        // Native commands (language keywords) - filtered by syntax context
        const allNativeCommands: { [key: string]: string } = {
            'if': 'Conditional statement - starts a conditional block',
            'then': 'Used with inline if statements',
            'else': 'Alternative branch in conditional blocks',
            'elseif': 'Additional condition in conditional blocks',
            'endif': 'Ends a conditional block',
            'def': 'Defines a user function - starts function definition',
            'enddef': 'Ends a function definition',
            'iftrue': 'Executes command if last value is truthy',
            'iffalse': 'Executes command if last value is falsy'
        };
        
        const native: Array<{ name: string; type: string; description: string }> = [];
        
        // Add block-starting keywords if allowed
        if (syntaxCtx.canUseBlockKeywords) {
            if (allNativeCommands['if']) {
                native.push({ name: 'if', type: 'native', description: allNativeCommands['if'] });
            }
            if (allNativeCommands['def']) {
                native.push({ name: 'def', type: 'native', description: allNativeCommands['def'] });
            }
            if (allNativeCommands['scope']) {
                native.push({ name: 'scope', type: 'native', description: allNativeCommands['scope'] });
            }
        }
        
        // Add conditional keywords if in if block
        if (syntaxCtx.canUseConditionalKeywords) {
            if (allNativeCommands['elseif']) {
                native.push({ name: 'elseif', type: 'native', description: allNativeCommands['elseif'] });
            }
            if (allNativeCommands['else']) {
                native.push({ name: 'else', type: 'native', description: allNativeCommands['else'] });
            }
        }
        
        // Add end keywords if in a block
        if (syntaxCtx.canUseEndKeywords) {
            if (context?.inIfBlock && allNativeCommands['endif']) {
                native.push({ name: 'endif', type: 'native', description: allNativeCommands['endif'] });
            }
            if (context?.inDefBlock && allNativeCommands['enddef']) {
                native.push({ name: 'enddef', type: 'native', description: allNativeCommands['enddef'] });
            }
            // endscope can be used to close a scope block
            if (allNativeCommands['endscope']) {
                native.push({ name: 'endscope', type: 'native', description: allNativeCommands['endscope'] });
            }
        }
        
        // Add iftrue/iffalse if we can start statements
        if (syntaxCtx.canStartStatement) {
            if (allNativeCommands['iftrue']) {
                native.push({ name: 'iftrue', type: 'native', description: allNativeCommands['iftrue'] });
            }
            if (allNativeCommands['iffalse']) {
                native.push({ name: 'iffalse', type: 'native', description: allNativeCommands['iffalse'] });
            }
        }
        
        // Builtin commands (root level commands, excluding module functions)
        // Only include if we can start statements
        const builtin: Array<{ name: string; type: string; description: string }> = [];
        if (syntaxCtx.canStartStatement) {
            for (const [name] of this.environment.builtins.entries()) {
                if (!name.includes('.')) {
                    const metadata = this.environment.metadata.get(name);
                    builtin.push({
                        name,
                        type: 'builtin',
                        description: metadata?.description || 'Builtin command'
                    });
                }
            }
            builtin.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        // Available modules - only show if we can start statements (for "use" command context)
        const modules: Array<{ name: string; type: string; description: string }> = [];
        if (syntaxCtx.canStartStatement) {
            for (const [name, metadata] of this.environment.moduleMetadata.entries()) {
                modules.push({
                    name,
                    type: 'module',
                    description: metadata.description || 'Module'
                });
            }
            modules.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        // Module functions (module.function format) - only if we can start statements
        const moduleFunctions: Array<{ name: string; type: string; description: string }> = [];
        if (syntaxCtx.canStartStatement) {
            for (const [name] of this.environment.builtins.entries()) {
                if (name.includes('.')) {
                    const metadata = this.environment.metadata.get(name);
                    moduleFunctions.push({
                        name,
                        type: 'moduleFunction',
                        description: metadata?.description || 'Module function'
                    });
                }
            }
            moduleFunctions.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        // User-defined functions - only if we can start statements
        const userFunctions: Array<{ name: string; type: string; description: string }> = [];
        if (syntaxCtx.canStartStatement) {
            for (const name of this.environment.functions.keys()) {
                userFunctions.push({
                    name,
                    type: 'userFunction',
                    description: 'User-defined function'
                });
            }
            userFunctions.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        return {
            native,
            builtin,
            modules,
            moduleFunctions,
            userFunctions
        };
    }

    /**
     * Check if a script needs more input (incomplete block)
     * Returns { needsMore: true, waitingFor: 'endif' | 'enddef' | 'endfor' | 'endscope' | 'subexpr' | 'paren' | 'object' | 'array' } if incomplete,
     * or { needsMore: false } if complete.
     */
    needsMoreInput(script: string): { needsMore: boolean; waitingFor?: 'endif' | 'enddef' | 'endfor' | 'endscope' | 'subexpr' | 'paren' | 'object' | 'array' } {
        try {
            const lines = splitIntoLogicalLines(script);
            const parser = new Parser(lines);
            parser.parse();
            return { needsMore: false };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            
            // Check for missing block closers
            if (errorMessage.includes('missing endif')) {
                return { needsMore: true, waitingFor: 'endif' };
            }
            if (errorMessage.includes('missing enddef')) {
                return { needsMore: true, waitingFor: 'enddef' };
            }
            if (errorMessage.includes('missing endfor')) {
                return { needsMore: true, waitingFor: 'endfor' };
            }
            if (errorMessage.includes('missing endscope')) {
                return { needsMore: true, waitingFor: 'endscope' };
            }
            
            // NEW: unclosed $( ... ) subexpression  keep reading lines
            if (errorMessage.includes('unclosed subexpression')) {
                return { needsMore: true, waitingFor: 'subexpr' };
            }
            
            // NEW: unclosed parenthesized function call fn(...)  keep reading lines
            if (errorMessage.includes('unclosed parenthesized function call')) {
                return { needsMore: true, waitingFor: 'paren' };
            }
            
            // NEW: unclosed object literal { ... }  keep reading lines
            if (errorMessage.includes('unclosed object literal')) {
                return { needsMore: true, waitingFor: 'object' };
            }
            
            // NEW: unclosed array literal [ ... ]  keep reading lines
            if (errorMessage.includes('unclosed array literal')) {
                return { needsMore: true, waitingFor: 'array' };
            }
            
            // If it's a different error, the script is malformed but complete
            // (we'll let executeScript handle the actual error)
            return { needsMore: false };
        }
    }

    /**
     * Get the AST without execution state
     * Returns a JSON-serializable AST array
     * 
     * Note: This method only parses the script, it does not execute it.
     */
    getAST(script: string): any[] {
        // Parse the script to get AST
        const lines = splitIntoLogicalLines(script);
        const parser = new Parser(lines);
        const statements = parser.parse();

        // Serialize AST without execution state
        const ast = statements.map((stmt) => {
            return this.serializeStatement(stmt);
        });

        return ast;
    }

    /**
     * Get extracted function definitions (def/enddef blocks) from a script
     * Returns a JSON-serializable array of function definitions
     * 
     * Note: This method only parses the script, it does not execute it.
     */
    getExtractedFunctions(script: string): any[] {
        // Parse the script to extract functions
        const lines = splitIntoLogicalLines(script);
        const parser = new Parser(lines);
        parser.parse(); // Parse to extract functions
        
        const extractedFunctions = parser.getExtractedFunctions();
        
        // Serialize functions
        return extractedFunctions.map((func) => {
            return {
                name: func.name,
                paramNames: func.paramNames,
                body: func.body.map((stmt) => this.serializeStatement(stmt))
            };
        });
    }

    /**
     * Find the module name for a given function name
     * Returns the module name if found, null otherwise
     */
    private findModuleName(functionName: string): string | null {
        // If the function name contains a dot, extract the module name
        if (functionName.includes('.')) {
            const parts = functionName.split('.');
            return parts[0] || null;
        }

        // Check if currentModule is set
        if (this.environment.currentModule) {
            // Verify that the function exists in this module
            const fullName = `${this.environment.currentModule}.${functionName}`;
            if (this.environment.builtins.has(fullName) || this.environment.metadata.has(fullName)) {
                return this.environment.currentModule;
            }
        }

        // Search through builtins and metadata to find which module this function belongs to
        for (const [name] of this.environment.builtins.entries()) {
            if (name.includes('.') && name.endsWith(`.${functionName}`)) {
                const parts = name.split('.');
                return parts[0] || null;
            }
        }

        for (const [name] of this.environment.metadata.entries()) {
            if (name.includes('.') && name.endsWith(`.${functionName}`)) {
                const parts = name.split('.');
                return parts[0] || null;
            }
        }

        // Check if it's a global builtin (no module)
        if (this.environment.builtins.has(functionName) || this.environment.metadata.has(functionName)) {
            return null; // Global function, no module
        }

        return null;
    }

    /**
     * Serialize a statement to JSON without execution state
     */
    private serializeStatement(stmt: Statement): any {
        const base: any = {
            type: stmt.type,
            lastValue: null
        };

        // Add comments if present
        const comments = (stmt as any).comments;
        if (comments && comments.length > 0) {
            base.comments = comments;
        }

        switch (stmt.type) {
            case 'command':
                const moduleName = this.findModuleName(stmt.name);
                return {
                    ...base,
                    name: stmt.name,
                    module: moduleName,
                    args: stmt.args.map(arg => this.serializeArg(arg))
                };
            case 'assignment':
                return {
                    ...base,
                    targetName: stmt.targetName,
                    targetPath: stmt.targetPath,
                    command: stmt.command ? this.serializeStatement(stmt.command) : undefined,
                    literalValue: stmt.literalValue,
                    isLastValue: stmt.isLastValue
                };
            case 'shorthand':
                return {
                    ...base,
                    targetName: stmt.targetName
                };
            case 'inlineIf':
                return {
                    ...base,
                    conditionExpr: stmt.conditionExpr,
                    command: this.serializeStatement(stmt.command)
                };
            case 'ifBlock':
                return {
                    ...base,
                    conditionExpr: stmt.conditionExpr,
                    thenBranch: stmt.thenBranch.map(s => this.serializeStatement(s)),
                    elseifBranches: stmt.elseifBranches?.map(branch => ({
                        condition: branch.condition,
                        body: branch.body.map(s => this.serializeStatement(s))
                    })),
                    elseBranch: stmt.elseBranch?.map(s => this.serializeStatement(s))
                };
            case 'ifTrue':
                return {
                    ...base,
                    command: this.serializeStatement(stmt.command)
                };
            case 'ifFalse':
                return {
                    ...base,
                    command: this.serializeStatement(stmt.command)
                };
            case 'define':
                return {
                    ...base,
                    name: stmt.name,
                    paramNames: stmt.paramNames,
                    body: stmt.body.map(s => this.serializeStatement(s))
                };
            case 'scope':
                return {
                    ...base,
                    body: stmt.body.map(s => this.serializeStatement(s))
                };
            case 'forLoop':
                return {
                    ...base,
                    varName: stmt.varName,
                    iterableExpr: stmt.iterableExpr,
                    body: stmt.body.map(s => this.serializeStatement(s))
                };
            case 'return':
                return {
                    ...base,
                    value: stmt.value ? this.serializeArg(stmt.value) : undefined
                };
            case 'break':
                return {
                    ...base
                };
            case 'comment':
                return {
                    ...base,
                    text: stmt.text,
                    comments: stmt.comments,
                    lineNumber: stmt.lineNumber
                };
        }
    }

    /**
     * Serialize an argument to JSON
     */
    private serializeArg(arg: Arg): any {
        switch (arg.type) {
            case 'subexpr':
                return { type: 'subexpr', code: arg.code };
            case 'var':
                return { type: 'var', name: arg.name, path: arg.path };
            case 'lastValue':
                return { type: 'lastValue' };
            case 'number':
                return { type: 'number', value: arg.value };
            case 'string':
                return { type: 'string', value: arg.value };
            case 'literal':
                return { type: 'literal', value: arg.value };
            case 'namedArgs':
                const serialized: Record<string, any> = {};
                for (const [key, valueArg] of Object.entries(arg.args)) {
                    serialized[key] = this.serializeArg(valueArg);
                }
                return { type: 'namedArgs', args: serialized };
        }
    }

    /**
     * Execute a RobinPath script
     */
    async executeScript(script: string): Promise<Value> {
        // Split into logical lines (handles ; separator)
        const lines = splitIntoLogicalLines(script);
        const parser = new Parser(lines);
        const statements = parser.parse();
        
        // Register extracted function definitions first (before executing other statements)
        const extractedFunctions = parser.getExtractedFunctions();
        for (const func of extractedFunctions) {
            this.environment.functions.set(func.name, func);
        }
        
        const executor = new Executor(this.environment, null);
        this.lastExecutor = executor;
        const result = await executor.execute(statements);
        return result;
    }

    /**
     * Execute a single line (for REPL)
     * Uses a persistent executor to maintain state ($, variables) between calls.
     * Functions and builtins persist across calls.
     */
    async executeLine(line: string): Promise<Value> {
        // Split into logical lines (handles ; separator)
        const lines = splitIntoLogicalLines(line);
        const parser = new Parser(lines);
        const statements = parser.parse();
        
        // Register extracted function definitions first (before executing other statements)
        const extractedFunctions = parser.getExtractedFunctions();
        for (const func of extractedFunctions) {
            this.environment.functions.set(func.name, func);
        }
        
        if (!this.persistentExecutor) {
            this.persistentExecutor = new Executor(this.environment, null);
        }
        
        this.lastExecutor = this.persistentExecutor;
        const result = await this.persistentExecutor.execute(statements);
        return result;
    }

    /**
     * Get the last value ($)
     * Returns the value from the most recent execution (script or REPL line).
     */
    getLastValue(): Value {
        if (this.lastExecutor) {
            return this.lastExecutor.getCurrentFrame().lastValue;
        }
        return null;
    }

    /**
     * REPL-friendly execution that supports multi-line blocks (if/def/for and $( ... )).
     * 
     * Usage pattern:
     *  - Call this for every user-entered line.
     *  - If done === false, keep collecting lines.
     *  - When done === true, value is the execution result and the buffer is cleared.
     */
    async executeReplLine(line: string): Promise<{ done: boolean; value: Value | null; waitingFor?: string }> {
        // Append the new line to the buffer (with newline if needed)
        this.replBuffer = this.replBuffer
            ? this.replBuffer + '\n' + line
            : line;

        // Ask if the accumulated buffer is syntactically complete
        const more = this.needsMoreInput(this.replBuffer);

        if (more.needsMore) {
            // Not ready yet  tell caller to keep reading input
            return { done: false, value: null, waitingFor: more.waitingFor };
        }

        // The block is complete  execute it as a script
        const result = await this.executeScript(this.replBuffer);

        // Clear buffer for the next block
        this.replBuffer = '';

        return { done: true, value: result };
    }

    /**
     * Generate a UUID v4
     */
    private generateUUID(): string {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    /**
     * Create a new thread/session.
     * Each thread has its own variables, functions, and $,
     * but shares builtins and metadata with the root interpreter.
     * 
     * @param id Optional thread ID. If not provided, a UUID will be generated.
     * @returns The created thread
     * 
     * @example
     * const rp = new RobinPath();
     * const thread = rp.createThread('my-thread');
     * await thread.executeScript('math.add 5 5');
     * console.log(thread.getLastValue()); // 10
     */
    createThread(id?: string): RobinPathThread {
        const threadId = id || this.generateUUID();
        
        // Check if thread with this ID already exists
        if (this.threads.has(threadId)) {
            throw new Error(`Thread with ID "${threadId}" already exists`);
        }
        
        const thread = new RobinPathThread(this.environment, threadId, this);
        this.threads.set(threadId, thread);
        
        // Set as current thread if no current thread exists
        if (!this.currentThread) {
            this.currentThread = thread;
        }
        
        return thread;
    }

    /**
     * Get a thread by ID
     */
    getThread(id: string): RobinPathThread | null {
        return this.threads.get(id) ?? null;
    }

    /**
     * List all threads with their IDs
     */
    listThreads(): Array<{ id: string; isCurrent: boolean }> {
        const threads: Array<{ id: string; isCurrent: boolean }> = [];
        for (const [id, thread] of this.threads.entries()) {
            threads.push({
                id,
                isCurrent: thread === this.currentThread
            });
        }
        return threads;
    }

    /**
     * Switch to a different thread
     */
    useThread(id: string): void {
        const thread = this.threads.get(id);
        if (!thread) {
            throw new Error(`Thread with ID "${id}" not found`);
        }
        this.currentThread = thread;
    }

    /**
     * Check if thread control is enabled
     */
    isThreadControlEnabled(): boolean {
        return this.threadControl;
    }

    /**
     * Close a thread by ID
     * If the closed thread is the current thread, currentThread is set to null
     */
    closeThread(id: string): void {
        const thread = this.threads.get(id);
        if (!thread) {
            throw new Error(`Thread with ID "${id}" not found`);
        }
        
        // If this is the current thread, clear currentThread
        if (this.currentThread === thread) {
            this.currentThread = null;
        }
        
        // Remove from threads map
        this.threads.delete(id);
    }

    /**
     * Get a variable value
     */
    getVariable(name: string): Value {
        return this.environment.variables.get(name) ?? null;
    }

    /**
     * Set a variable value (for external use)
     */
    setVariable(name: string, value: Value): void {
        this.environment.variables.set(name, value);
    }

    /**
     * Get the next statement index that would execute after a given statement.
     * This method analyzes the AST structure to determine execution flow.
     * 
     * @param statements The array of all statements
     * @param currentIndex The index of the current statement
     * @param context Optional context for conditional branches (which branch was taken)
     * @returns The index of the next statement to execute, or -1 if execution ends
     */
    getNextStatementIndex(
        statements: Statement[],
        currentIndex: number,
        context?: { ifBlockBranch?: 'then' | 'elseif' | 'else' | null; forLoopIteration?: number }
    ): number {
        if (currentIndex < 0 || currentIndex >= statements.length) {
            return -1;
        }

        const currentStmt = statements[currentIndex];

        // Handle return statements - execution stops
        if (currentStmt.type === 'return') {
            return -1;
        }

        // Handle comments - next is the next statement
        if (currentStmt.type === 'comment') {
            return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
        }

        // Handle ifBlock - next depends on which branch executes
        if (currentStmt.type === 'ifBlock') {
            const branch = context?.ifBlockBranch;
            
            // If we know which branch was taken, find the last statement in that branch
            if (branch === 'then' && currentStmt.thenBranch && currentStmt.thenBranch.length > 0) {
                // After then branch, next is the statement after the ifBlock
                return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
            }
            
            if (branch === 'elseif' && currentStmt.elseifBranches) {
                // After elseif branch, next is the statement after the ifBlock
                return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
            }
            
            if (branch === 'else' && currentStmt.elseBranch && currentStmt.elseBranch.length > 0) {
                // After else branch, next is the statement after the ifBlock
                return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
            }
            
            // If no branch was taken (condition was false and no else), next is after ifBlock
            if (branch === null) {
                return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
            }
            
            // Default: if we don't know which branch, assume then branch
            if (currentStmt.thenBranch && currentStmt.thenBranch.length > 0) {
                return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
            }
            
            // No then branch, check elseif or else
            if (currentStmt.elseifBranches && currentStmt.elseifBranches.length > 0) {
                return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
            }
            
            if (currentStmt.elseBranch && currentStmt.elseBranch.length > 0) {
                return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
            }
            
            // No branches, next is after ifBlock
            return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
        }

        // Handle forLoop - next is first statement in body, then after loop completes, next is after the loop
        if (currentStmt.type === 'forLoop') {
            // If we're at the start of the loop, next is first statement in body
            if (currentStmt.body && currentStmt.body.length > 0) {
                // The body statements are nested, so we need to handle them differently
                // For now, after loop completes, next is after the loop
                return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
            }
            return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
        }

        // Handle define - next is after the define (define doesn't execute, just registers)
        if (currentStmt.type === 'define') {
            return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
        }

        // Handle scope - next is after the scope (scope executes immediately)
        if (currentStmt.type === 'scope') {
            return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
        }

        // Handle inlineIf - next is after the inlineIf
        if (currentStmt.type === 'inlineIf') {
            return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
        }

        // Handle ifTrue/ifFalse - next is after the statement
        if (currentStmt.type === 'ifTrue' || currentStmt.type === 'ifFalse') {
            return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
        }

        // Default: next statement in sequence
        return currentIndex + 1 < statements.length ? currentIndex + 1 : -1;
    }
}
