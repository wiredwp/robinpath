# RobinPath Test Script
# This script tests various features of the RobinPath interpreter

# Test 1: Basic math operations
math.add 10 20
$result
log "Test 1 - Addition result:" $result

math.multiply $result 5
log "Test 1 - Multiplication result:" $

# Test 2: Variable assignment
$balance = 100
log "Test 2 - Balance:" $balance

# Test 3: Inline conditional
if $balance > 0 then log "Test 3 - Balance is positive"

# Test 4: Block if with else
$score = 85
if $score >= 90
  log "Test 4 - Grade: A"
elseif $score >= 80
  log "Test 4 - Grade: B"
elseif $score >= 70
  log "Test 4 - Grade: C"
else
  log "Test 4 - Grade: F"
endif

# Test 5: User-defined function
def greet
$1
$2
log "Test 5 - Hello" $1
log "Test 5 - Your age is" $2
math.add $2 1
enddef

greet "Alice" 25
log "Test 5 - Next year age:" $

# Test 6: Function with return value
def sum_and_double
math.add $1 $2
math.multiply $ 2
enddef

sum_and_double 10 20
log "Test 6 - Sum and double result:" $

# Test 7: Nested conditionals
$value = 42
if $value > 0
  if $value < 50
    log "Test 7 - Value is between 0 and 50"
  else
    log "Test 7 - Value is 50 or greater"
  endif
else
  log "Test 7 - Value is negative or zero"
endif

# Test 8: Shorthand assignment
math.add 5 3
$sum
log "Test 8 - Shorthand assignment result:" $sum

# Test 9: Using last value ($)
math.add 7 8
math.multiply $ 2
log "Test 9 - Chained operations result:" $

# Test 10: Complex expression
$age = 18
$citizen = "yes"
if ($age >= 18) && ($citizen == "yes") then log "Test 10 - Loan approved"

# Test 11: For loop
for $i in range 1 5
  log "Test 11 - Loop iteration:" $i
endfor

# Test 12: Nested for loop
for $i in range 1 3
  for $j in range 1 2
    log "Test 12 - Nested loop:" $i $j
  endfor
endfor

# Test 13: For loop with array
$numbers = range 10 12
for $num in $numbers
  log "Test 13 - Number:" $num
endfor

# Test 14: For loop inside if
$count = 3
if $count > 0
  for $i in range 1 $count
    log "Test 14 - Conditional loop:" $i
  endfor
endif

# Test 15: If inside for loop
for $i in range 1 5
  if $i > 3
    log "Test 15 - Greater than 3:" $i
  endif
endfor

# Test 16: Math module tests
clear
do
  math.add 5 10
  test.assertEqual $ 15 "Math.add failed"
enddo
clear
do
  math.add 1 2 3 4
  test.assertEqual $ 10 "Math.add multiple args failed"
enddo
clear
do
  math.multiply 5 3
  test.assertEqual $ 15 "Math.multiply failed"
enddo
clear
do
  math.multiply 2 3 4
  test.assertEqual $ 24 "Math.multiply multiple args failed"
enddo
clear
do
  math.subtract 10 3
  test.assertEqual $ 7 "Math.subtract failed"
enddo
clear
do
  math.divide 15 3
  test.assertEqual $ 5 "Math.divide failed"
enddo
clear
do
  math.modulo 17 5
  test.assertEqual $ 2 "Math.modulo failed"
enddo
clear
do
  math.power 2 8
  test.assertEqual $ 256 "Math.power failed"
enddo
clear
do
  math.sqrt 16
  test.assertEqual $ 4 "Math.sqrt failed"
enddo
clear
do
  math.abs -5
  test.assertEqual $ 5 "Math.abs failed"
enddo
clear
do
  math.round 3.7
  test.assertEqual $ 4 "Math.round failed"
enddo
clear
do
  math.floor 3.7
  test.assertEqual $ 3 "Math.floor failed"
enddo
clear
do
  math.ceil 3.2
  test.assertEqual $ 4 "Math.ceil failed"
enddo
clear
do
  math.min 5 2 8 1
  test.assertEqual $ 1 "Math.min failed"
enddo
clear
do
  math.max 5 2 8 1
  test.assertEqual $ 8 "Math.max failed"
enddo
log "Test 16 - Math module: All passed"

# Test 17: String module tests
clear
do
  string.length "hello"
  test.assertEqual $ 5 "String.length failed"
enddo
clear
do
  string.substring "hello" 1 4
  test.assertEqual $ "ell" "String.substring failed"
enddo
clear
do
  string.toUpperCase "hello"
  test.assertEqual $ "HELLO" "String.toUpperCase failed"
enddo
clear
do
  string.toLowerCase "HELLO"
  test.assertEqual $ "hello" "String.toLowerCase failed"
enddo
clear
do
  string.trim "  hello  "
  test.assertEqual $ "hello" "String.trim failed"
enddo
clear
do
  string.replace "hello world" "world" "universe"
  test.assertEqual $ "hello universe" "String.replace failed"
enddo
clear
do
  string.replaceAll "a b a" "a" "x"
  test.assertEqual $ "x b x" "String.replaceAll failed"
enddo


string.split "a,b,c" ","
$splitArr = $

clear
do
  array.get $splitArr 0
  test.assertEqual $ "a" "String.split first element failed"
enddo
string.startsWith "hello" "he"
test.assertTrue $ "String.startsWith failed"
string.endsWith "hello" "lo"
test.assertTrue $ "String.endsWith failed"
string.contains "hello" "ell"
test.assertTrue $ "String.contains failed"
clear
do
  string.indexOf "hello" "l"
  test.assertEqual $ 2 "String.indexOf failed"
enddo
clear
do
  string.lastIndexOf "hello" "l"
  test.assertEqual $ 3 "String.lastIndexOf failed"
enddo
clear
do
  string.charAt "hello" 1
  test.assertEqual $ "e" "String.charAt failed"
enddo
clear
do
  string.padStart "5" 3 "0"
  test.assertEqual $ "005" "String.padStart failed"
enddo
clear
do
  string.padEnd "5" 3 "0"
  test.assertEqual $ "500" "String.padEnd failed"
enddo
clear
do
  string.repeat "ha" 3
  test.assertEqual $ "hahaha" "String.repeat failed"
enddo
log "Test 17 - String module: All passed"

# Test 18: Array module tests
$arr = range 1 5
clear
do
  array.length $arr
  test.assertEqual $ 5 "Array.length failed"
enddo
clear
do
  array.get $arr 2
  test.assertEqual $ 3 "Array.get failed"
enddo
clear

array.slice $arr 1 4
$sliced = $

do
  array.length $sliced
  test.assertEqual $ 3 "Array.slice length failed"
enddo
clear
do
  array.get $sliced 0
  test.assertEqual $ 2 "Array.slice content failed"
enddo

array.push $arr 6
$pushed = $

clear
do
  array.length $pushed
  test.assertEqual $ 6 "Array.push length failed"
enddo
clear
do
  array.get $pushed 5
  test.assertEqual $ 6 "Array.push content failed"
enddo

$arr1 = range 1 2
$arr2 = range 3 4

array.concat $arr1 $arr2
$concatted = $

clear
do
  array.length $concatted
  test.assertEqual $ 4 "Array.concat length failed"
enddo
clear
do
  array.get $concatted 0
  test.assertEqual $ 1 "Array.concat content failed"
enddo
clear
do
  array.join $arr ","
  test.assertEqual $ "1,2,3,4,5" "Array.join failed"
enddo
clear

array.create 1 2 3
$created = $


do
  array.length $created
  test.assertEqual $ 3 "Array.create length failed"
enddo
clear
do
  array.get $created 0
  test.assertEqual $ 1 "Array.create first element failed"
enddo
clear
do
  array.get $created 1
  test.assertEqual $ 2 "Array.create second element failed"
enddo
clear
do
  array.get $created 2
  test.assertEqual $ 3 "Array.create third element failed"
enddo

array.create "hello" "world" 42 true
$mixed = $

clear
do
  array.length $mixed
  test.assertEqual $ 4 "Array.create mixed types length failed"
enddo
clear
do
  array.get $mixed 0
  test.assertEqual $ "hello" "Array.create string element failed"
enddo
clear
do
  array.get $mixed 2
  test.assertEqual $ 42 "Array.create number element failed"
enddo
clear
do
  array.get $mixed 3
  test.assertEqual $ true "Array.create boolean element failed"
enddo
clear
do
  array.create
  $emptyCreated = $
  array.length $emptyCreated
  test.assertEqual $ 0 "Array.create empty array failed"
enddo
log "Test 18 - Array module: All passed"

# Test 19: Json module tests
$jsonStr = '{"name": "John", "age": 30}'
json.parse $jsonStr
$parsed = $
test.assertNotNull $parsed "Json.parse failed"
json.stringify $parsed
$stringified = $
string.contains $stringified "John"
test.assertTrue $ "Json.stringify failed"
json.isValid $jsonStr
test.assertTrue $ "Json.isValid failed"
log "Test 19 - Json module: All passed"

# Test 19a: obj command tests
obj
$emptyObj = $
test.assertType $emptyObj "object" "obj without args failed"
clear
do
  keys $emptyObj
  $emptyKeys = $
  array.length $emptyKeys
  test.assertEqual $ 0 "obj empty object keys failed"
enddo

obj '{name: "John", age: 30}'
$objCreated = $
test.assertEqual $objCreated.name "John" "obj command basic creation failed"
test.assertEqual $objCreated.age 30 "obj command with number failed"

obj '{nested: {key: "value"}, array: [1, 2, 3]}'
$complexObj = $
test.assertEqual $complexObj.nested.key "value" "obj command nested object failed"
test.assertEqual $complexObj.array[0] 1 "obj command with array failed"

obj '{unquoted: "works", singleQuotes: "also works", numbers: 42, bool: true}'
$json5Obj = $
test.assertEqual $json5Obj.unquoted "works" "obj command unquoted keys failed"
test.assertEqual $json5Obj.singleQuotes "also works" "obj command single quotes failed"
test.assertEqual $json5Obj.numbers 42 "obj command number values failed"
test.assertEqual $json5Obj.bool true "obj command boolean values failed"

obj '{trailing: "comma", allowed: true,}'
$trailingComma = $
test.assertEqual $trailingComma.trailing "comma" "obj command trailing comma failed"
test.assertEqual $trailingComma.allowed true "obj command trailing comma value failed"

log "Test 19a - obj command: All passed"

# Test 19a2: array builtin tests
array
$emptyArray = $
clear
do
  array.length $emptyArray
  test.assertEqual $ 0 "array without args failed"
enddo

array 1 2 3
$arr1 = $
clear
do
  array.length $arr1
  test.assertEqual $ 3 "array command length failed"
enddo
test.assertEqual $arr1[0] 1 "array command first element failed"
test.assertEqual $arr1[1] 2 "array command second element failed"
test.assertEqual $arr1[2] 3 "array command third element failed"

array "hello" "world" 42 true
$mixedArray = $
clear
do
  array.length $mixedArray
  test.assertEqual $ 4 "array command mixed types length failed"
enddo
test.assertEqual $mixedArray[0] "hello" "array command string element failed"
test.assertEqual $mixedArray[2] 42 "array command number element failed"
test.assertEqual $mixedArray[3] true "array command boolean element failed"

array 1 2 3 4 5
$numbers = $
clear
do
  math.add $numbers[0] $numbers[1]
  test.assertEqual $ 3 "array command in expressions failed"
enddo

log "Test 19a2 - array command: All passed"

# Test 19a3: Object and Array Literal Syntax {} and []
# Test empty object literal
{}

$emptyObjLit = $
test.assertType $emptyObjLit "object" "Empty object literal {} failed"
clear
do
  keys $emptyObjLit
  $emptyKeys = $
  array.length $emptyKeys
  test.assertEqual $ 0 "Empty object literal keys failed"
enddo

# Test basic object literal
{name: "John", age: 30}
$objLit = $
test.assertEqual $objLit.name "John" "Object literal basic creation failed"
test.assertEqual $objLit.age 30 "Object literal with number failed"

# Test object literal with nested object
{nested: {key: "value"}, array: [1, 2, 3]}
$complexObjLit = $
test.assertEqual $complexObjLit.nested.key "value" "Object literal nested object failed"
test.assertEqual $complexObjLit.array[0] 1 "Object literal with array failed"

# Test object literal with JSON5 features
{unquoted: "works", singleQuotes: "also works", numbers: 42, bool: true}
$json5ObjLit = $
test.assertEqual $json5ObjLit.unquoted "works" "Object literal unquoted keys failed"
test.assertEqual $json5ObjLit.singleQuotes "also works" "Object literal single quotes failed"
test.assertEqual $json5ObjLit.numbers 42 "Object literal number values failed"
test.assertEqual $json5ObjLit.bool true "Object literal boolean values failed"

# Test object literal with trailing comma
{trailing: "comma", allowed: true}
$trailingCommaLit = $
test.assertEqual $trailingCommaLit.trailing "comma" "Object literal trailing comma failed"
test.assertEqual $trailingCommaLit.allowed true "Object literal trailing comma value failed"

# Test empty array literal
[]
$emptyArrLit = $
clear
do
  array.length $emptyArrLit
  test.assertEqual $ 0 "Empty array literal [] failed"
enddo

# Test basic array literal
[1, 2, 3]
$arrLit = $
clear
do
  array.length $arrLit
  test.assertEqual $ 3 "Array literal length failed"
enddo
test.assertEqual $arrLit[0] 1 "Array literal first element failed"
test.assertEqual $arrLit[1] 2 "Array literal second element failed"
test.assertEqual $arrLit[2] 3 "Array literal third element failed"

# Test array literal with mixed types
["hello", "world", 42, true]
$mixedArrLit = $
clear
do
  array.length $mixedArrLit
  test.assertEqual $ 4 "Array literal mixed types length failed"
enddo
test.assertEqual $mixedArrLit[0] "hello" "Array literal string element failed"
test.assertEqual $mixedArrLit[2] 42 "Array literal number element failed"
test.assertEqual $mixedArrLit[3] true "Array literal boolean element failed"

# Test array literal in expressions
[1, 2, 3, 4, 5]
$numbersLit = $
clear
do
  math.add $numbersLit[0] $numbersLit[1]
  test.assertEqual $ 3 "Array literal in expressions failed"
enddo

# Test nested array literals
[[1, 2], [3, 4]]
$nestedArr = $
clear
do
  array.length $nestedArr
  test.assertEqual $ 2 "Nested array literal outer length failed"
enddo
clear
do
  array.length $nestedArr[0]
  test.assertEqual $ 2 "Nested array literal inner length failed"
enddo
test.assertEqual $nestedArr[0][0] 1 "Nested array literal access failed"
test.assertEqual $nestedArr[1][1] 4 "Nested array literal second array failed"

# Test array with objects
[{name: "Alice", age: 25}, {name: "Bob", age: 30}]
$arrWithObjs = $
clear
do
  array.length $arrWithObjs
  test.assertEqual $ 2 "Array with objects length failed"
enddo
test.assertEqual $arrWithObjs[0].name "Alice" "Array with objects first name failed"
test.assertEqual $arrWithObjs[1].age 30 "Array with objects second age failed"

# Test object with array of objects
{users: [{name: "Alice"}, {name: "Bob"}]}
$objWithArrOfObjs = $
test.assertEqual $objWithArrOfObjs.users[0].name "Alice" "Object with array of objects failed"
test.assertEqual $objWithArrOfObjs.users[1].name "Bob" "Object with array of objects second user failed"

# Test object literal in assignment
$assignedObj = {key: "value", num: 42}
test.assertEqual $assignedObj.key "value" "Object literal in assignment failed"
test.assertEqual $assignedObj.num 42 "Object literal in assignment number failed"

# Test array literal in assignment
$assignedArr = [10, 20, 30]
test.assertEqual $assignedArr[0] 10 "Array literal in assignment failed"
test.assertEqual $assignedArr[1] 20 "Array literal in assignment second element failed"

# Test object literal as function argument
clear
do
  get {name: "Test", value: 100} "name"
  test.assertEqual $ "Test" "Object literal as function argument failed"
enddo

# Test array literal as function argument
clear
do
  array.length [1, 2, 3, 4]
  test.assertEqual $ 4 "Array literal as function argument failed"
enddo

# Test object literal in parenthesized call
clear
do
  get({name: "John", age: 30} "name")
  test.assertEqual $ "John" "Object literal in parenthesized call failed"
enddo

# Test array literal in parenthesized call
clear
do
  array.length([1, 2, 3])
  test.assertEqual $ 3 "Array literal in parenthesized call failed"
enddo

# Test multi-line object literal
{
  name: "Multi",
  age: 25,
  city: "NYC"
}
$multiLineObj = $
test.assertEqual $multiLineObj.name "Multi" "Multi-line object literal failed"
test.assertEqual $multiLineObj.age 25 "Multi-line object literal age failed"
test.assertEqual $multiLineObj.city "NYC" "Multi-line object literal city failed"

# Test multi-line array literal
[
  1,
  2,
  3
]
$multiLineArr = $
clear
do
  array.length $multiLineArr
  test.assertEqual $ 3 "Multi-line array literal length failed"
enddo
test.assertEqual $multiLineArr[1] 2 "Multi-line array literal element failed"

# Test 19a4: Comprehensive multi-line object and array literal tests
log "Test 19a4 - Comprehensive Multi-line Object and Array Literals"

# Test multi-line object literal with nested objects
{
  user: {
    name: "Alice",
    age: 30
  },
  settings: {
    theme: "dark",
    notifications: true
  }
}
$nestedMultiLineObj = $
test.assertEqual $nestedMultiLineObj.user.name "Alice" "Multi-line nested object literal failed"
test.assertEqual $nestedMultiLineObj.settings.theme "dark" "Multi-line nested object literal settings failed"

# Test multi-line object literal with arrays
{
  tags: [
    "javascript",
    "typescript",
    "node"
  ],
  scores: [
    100,
    95,
    88
  ]
}
$objWithArrays = $
clear
do
  array.length $objWithArrays.tags
  test.assertEqual $ 3 "Multi-line object with array - tags length failed"
enddo
test.assertEqual $objWithArrays.tags[0] "javascript" "Multi-line object with array - first tag failed"
test.assertEqual $objWithArrays.scores[1] 95 "Multi-line object with array - second score failed"

# Test multi-line array literal with objects
[
  {
    id: 1,
    name: "First"
  },
  {
    id: 2,
    name: "Second"
  },
  {
    id: 3,
    name: "Third"
  }
]
$arrWithObjs = $
clear
do
  array.length $arrWithObjs
  test.assertEqual $ 3 "Multi-line array with objects - length failed"
enddo
test.assertEqual $arrWithObjs[0].id 1 "Multi-line array with objects - first id failed"
test.assertEqual $arrWithObjs[1].name "Second" "Multi-line array with objects - second name failed"

# Test multi-line array literal with nested arrays
[
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
$nestedMultiLineArr = $
clear
do
  array.length $nestedMultiLineArr
  test.assertEqual $ 3 "Multi-line nested array - outer length failed"
enddo
clear
do
  array.length $nestedMultiLineArr[0]
  test.assertEqual $ 3 "Multi-line nested array - inner length failed"
enddo
test.assertEqual $nestedMultiLineArr[1][2] 6 "Multi-line nested array - access failed"

# Test multi-line object literal in assignment
$assignedMultiLineObj = {
  key1: "value1",
  key2: "value2",
  key3: 42
}
test.assertEqual $assignedMultiLineObj.key1 "value1" "Multi-line object in assignment - key1 failed"
test.assertEqual $assignedMultiLineObj.key3 42 "Multi-line object in assignment - key3 failed"

# Test multi-line array literal in assignment
$assignedMultiLineArr = [
  "a",
  "b",
  "c"
]
clear
do
  array.length $assignedMultiLineArr
  test.assertEqual $ 3 "Multi-line array in assignment - length failed"
enddo
test.assertEqual $assignedMultiLineArr[2] "c" "Multi-line array in assignment - element failed"

# Test multi-line object literal as function argument (direct)
clear
do
  get {
    name: "Test",
    value: 100,
    active: true
  } "name"
  test.assertEqual $ "Test" "Multi-line object as function argument (direct) failed"
enddo

# Test multi-line object literal as function argument (via variable)
clear
do
  get {
    name: "Test",
    value: 100,
    active: true
  } "name"
  test.assertEqual $ "Test" "Multi-line object as function argument (via variable) failed"
enddo

# Test multi-line array literal as function argument
clear
do
  array.length [
    10,
    20,
    30,
    40
  ]
  test.assertEqual $ 4 "Multi-line array as function argument failed"
enddo

# Test multi-line object literal in parenthesized call
clear
do
  get({
    id: 123,
    status: "active"
  } "id")
  test.assertEqual $ 123 "Multi-line object in parenthesized call failed"
enddo

# Test multi-line array literal in parenthesized call
clear
do
  array.length([
    "one",
    "two",
    "three"
  ])
  test.assertEqual $ 3 "Multi-line array in parenthesized call failed"
enddo

# Test deeply nested multi-line structures
{
  level1: {
    level2: {
      level3: [
        {
          deep: "value"
        }
      ]
    }
  }
}
$deepNested = $
test.assertEqual $deepNested.level1.level2.level3[0].deep "value" "Deeply nested multi-line structure failed"

# Test multi-line object with trailing comma
{
  a: 1,
  b: 2,
  c: 3,
}
$trailingCommaObj = $
test.assertEqual $trailingCommaObj.a 1 "Multi-line object with trailing comma failed"

# Test multi-line array with trailing comma
[
  1,
  2,
  3,
]
$trailingCommaArr = $
clear
do
  array.length $trailingCommaArr
  test.assertEqual $ 3 "Multi-line array with trailing comma failed"
enddo

# Test multi-line object with empty lines (should be handled gracefully)
{
  name: "Test",

  age: 25
}
$withEmptyLines = $
test.assertEqual $withEmptyLines.name "Test" "Multi-line object with empty lines failed"
test.assertEqual $withEmptyLines.age 25 "Multi-line object with empty lines - age failed"

log "Test 19a4 - Comprehensive Multi-line Object and Array Literals: All passed"

# Test object literal with string values containing special chars
{message: "Hello, world!", count: 5}
$specialObj = $
test.assertEqual $specialObj.message "Hello, world!" "Object literal with special chars failed"

# Test array literal with null and boolean
[null, true, false, "text"]
$mixedTypesArr = $
test.assertEqual $mixedTypesArr[0] null "Array literal with null failed"
test.assertEqual $mixedTypesArr[1] true "Array literal with true failed"
test.assertEqual $mixedTypesArr[2] false "Array literal with false failed"
test.assertEqual $mixedTypesArr[3] "text" "Array literal with string failed"

# Test 19a4: Variable interpolation in object and array literals
$a = 1
$b = { a: $a }
test.assertEqual $b.a 1 "Variable interpolation in object literal failed"

$key = "key"
$b = { [$key]: 1 }
test.assertEqual $b.key 1 "Computed property name in object literal failed"

$num = 42
$arr = [$num, 43]
test.assertEqual $arr[0] 42 "Variable interpolation in array literal failed"
test.assertEqual $arr[1] 43 "Variable interpolation in array literal - second element failed"

$name = "John"
$age = 30
$obj = { name: $name, age: $age }
test.assertEqual $obj.name "John" "Multiple variable interpolation in object literal failed"
test.assertEqual $obj.age 30 "Multiple variable interpolation in object literal - age failed"

$nested = { inner: $a }
$outer = { nested: $nested, value: $a }
test.assertEqual $outer.nested.inner 1 "Nested object with variable interpolation failed"
test.assertEqual $outer.value 1 "Nested object with variable interpolation - outer value failed"

log "Test 19a4 - Variable Interpolation in Object and Array Literals: All passed"

log "Test 19a3 - Object and Array Literals {} and []: All passed"

# Test 19b: Object module tests (keys, values, entries, merge, clone)
# Note: get and set are now built-in commands (see Test 29a and Test 29b)
$testObj = $parsed
keys $testObj
$keys = $
test.assertContains $keys "name" "Object.keys failed"
values $testObj
$values = $
test.assertContains $values "John" "Object.values failed"
json.parse '{"a": 1}'
$obj1 = $
json.parse '{"b": 2}'
$obj2 = $
merge $obj1 $obj2
$merged = $
clear
do
  get $merged "a"
  test.assertEqual $ 1 "Object.merge failed"
enddo
clear
do
  get $merged "b"
  test.assertEqual $ 2 "Object.merge failed"
enddo
clone $parsed
$cloned = $
clear
do
  get $cloned "name"
  test.assertEqual $ "John" "Object.clone failed"
enddo
entries $cloned
$entries = $
test.assertNotNull $entries "Object.entries failed"
log "Test 19b - Object module: All passed"

# Test 20: Time module tests
time.now
$now = $
test.assertNotNull $now "Time.now failed"
test.assertType $now "string" "Time.now type failed"
time.timestamp
$ts = $
test.assertType $ts "number" "Time.timestamp type failed"
test.assertGreater $ts 0 "Time.timestamp value failed"
time.format "2024-01-15"
$formatted = $
test.assertType $formatted "string" "Time.format type failed"
time.addDays "2024-01-15T00:00:00.000Z" 7
$added = $
test.assertNotNull $added "Time.addDays failed"
clear
do
  time.diffDays "2024-01-01" "2024-01-08"
  test.assertEqual $ 7 "Time.diffDays failed"
enddo
log "Test 20 - Time module: All passed"

# Test 21: Random module tests
random.int 1 10
$randInt = $
test.assertGreaterOrEqual $randInt 1 "Random.int min failed"
test.assertLessOrEqual $randInt 10 "Random.int max failed"
random.float
$randFloat = $
test.assertGreaterOrEqual $randFloat 0 "Random.float min failed"
test.assertLess $randFloat 1 "Random.float max failed"
random.uuid
$uuid = $
test.assertType $uuid "string" "Random.uuid type failed"
clear
do
  string.length $uuid
  test.assertGreater $ 30 "Random.uuid length failed"
enddo
$arr = range 1 5
random.choice $arr
$choice = $
test.assertContains $arr $choice "Random.choice failed"
log "Test 21 - Random module: All passed"

# Test 22: Variable-to-variable assignment
$city = "New York"
log "Test 22 - Original city:" $city
$city2 = $city
test.assertEqual $city2 "New York" "Variable-to-variable assignment failed"
log "Test 22 - Assigned city:" $city2
$number1 = 42
$number2 = $number1
test.assertEqual $number2 42 "Number variable assignment failed"
$bool1 = true
$bool2 = $bool1
test.assertEqual $bool2 true "Boolean variable assignment failed"
log "Test 22 - Variable assignment: All passed"

# Test 23: Return statement in functions
def return_value
  return 100
  log "This should not execute"
enddef

clear
do
  return_value
  test.assertEqual $ 100 "Function return value failed"
enddo

def return_variable
  $result = 200
  return $result
  log "This should not execute"
enddef

clear
do
  return_variable
  test.assertEqual $ 200 "Function return variable failed"
enddo

def return_expression
  math.add 10 20
  return $
  log "This should not execute"
enddef

clear
do
  return_expression
  test.assertEqual $ 30 "Function return expression failed"
enddo

def return_early
  if true
    return "early"
  endif
  log "This should not execute"
enddef

clear
do
  return_early
  test.assertEqual $ "early" "Function early return failed"
enddo

def return_no_value
  $temp = 50
  return
  log "This should not execute"
enddef

clear
do
  return_no_value
  test.assertEqual $ null "Function return last value failed"
enddo
log "Test 23 - Return in functions: All passed"

# Test 24: Return statement in global do
# Note: We'll test this carefully since it terminates execution
# We'll create a separate test that can be run independently

def test_global_return
  $test_val = "global_return_test"
  return $test_val
  log "This should not execute"
enddef

# Test that return works in nested contexts
def outer_func
  def inner_func
    return "inner"
  enddef
  inner_func
  return $
enddef

clear
do
  outer_func
  test.assertEqual $ "inner" "Nested function return failed"
enddo
log "Test 24 - Return in nested contexts: All passed"

# Test 25: Return with different value types
def return_string
  return "hello"
enddef

clear
do
  return_string
  test.assertEqual $ "hello" "Return string failed"
enddo

def return_number
  return 42
enddef

clear
do
  return_number
  test.assertEqual $ 42 "Return number failed"
enddo

def return_boolean
  return true
enddef

clear
do
  return_boolean
  test.assertEqual $ true "Return boolean failed"
enddo

def return_null
  return null
enddef

clear
do
  return_null
  test.assertEqual $ null "Return null failed"
enddo

def return_subexpression
  return $(math.add 5 5)
enddef

clear
do
  return_subexpression
  test.assertEqual $ 10 "Return subexpression failed"
enddo
log "Test 25 - Return with different types: All passed"

# Test 26: Return in conditional blocks
def return_in_if
  if true
    return "if_return"
  endif
  return "after_if"
enddef

clear
do
  return_in_if
  test.assertEqual $ "if_return" "Return in if block failed"
enddo

def return_in_else
  if false
    $temp = "if"
  else
    return "else_return"
  endif
  return "after_else"
enddef

clear
do
  return_in_else
  test.assertEqual $ "else_return" "Return in else block failed"
enddo
log "Test 26 - Return in conditionals: All passed"

# Test 27: Return in loops
def return_in_for
  for $i in range 1 10
    if $i == 3
      return $i
    endif
  endfor
  return 0
enddef

clear
do
  return_in_for
  test.assertEqual $ 3 "Return in for loop failed"
enddo
log "Test 27 - Return in loops: All passed"

# Test 28: Complex variable assignment scenarios
$original = "test"
$copy1 = $original
$copy2 = $copy1
test.assertEqual $copy2 "test" "Chained variable assignment failed"

$num1 = 10
$num2 = $num1
$num3 = $num2
math.add $num3 5
$result = $
test.assertEqual $result 15 "Variable assignment in expressions failed"

$arr1 = range 1 3
$arr2 = $arr1
clear
do
  array.length $arr2
  test.assertEqual $ 3 "Array variable assignment failed"
enddo
log "Test 28 - Complex variable assignments: All passed"

# Test 29: set command (replaces assign)
$testVar = "original"
test.assertEqual $testVar "original" "Initial assignment failed"
set $testVar "assigned"
test.assertEqual $testVar "assigned" "set command failed"
set $testVar 42
test.assertEqual $testVar 42 "set command with number failed"
set $testVar true
test.assertEqual $testVar true "set command with boolean failed"
$sourceVar = "source value"
set $testVar $sourceVar
test.assertEqual $testVar "source value" "set command with variable failed"
math.add 10 20
set $testVar $
test.assertEqual $testVar 30 "set command with last value failed"

# Test set with fallback (3rd parameter)
$emptyVar = null
set $testVar $emptyVar "fallback value"
test.assertEqual $testVar "fallback value" "set with fallback for null failed"

$emptyVar = ""
set $testVar $emptyVar "fallback string"
test.assertEqual $testVar "fallback string" "set with fallback for empty string failed"

$emptyVar = null
set $testVar $emptyVar 42
test.assertEqual $testVar 42 "set with fallback number failed"

$emptyVar = null
set $testVar $emptyVar true
test.assertEqual $testVar true "set with fallback boolean failed"

json.parse '[]'
$emptyVar = $
set $testVar $emptyVar "fallback for empty array"
test.assertEqual $testVar "fallback for empty array" "set with fallback for empty array failed"

$emptyVar = "not empty"
set $testVar $emptyVar "fallback"
test.assertEqual $testVar "not empty" "set should not use fallback when value is not empty"

$emptyVar = 0
set $testVar $emptyVar "fallback"
test.assertEqual $testVar 0 "set should not use fallback for zero"

$emptyVar = false
set $testVar $emptyVar "fallback"
test.assertEqual $testVar false "set should not use fallback for false"
log "Test 29 - set command: All passed"

# Test 29a: get command (built-in)
log "Test 29a - get command (built-in)"

# Test basic get with object
json.parse '{"name": "John", "age": 30, "address": {"city": "NYC", "zip": 10001}}'
$user = $
clear
do
  get $user "name"
  test.assertEqual $ "John" "get command - basic property failed"
enddo

clear
do
  get $user "age"
  test.assertEqual $ 30 "get command - number property failed"
enddo

# Test get with nested path
clear
do
  get $user "address.city"
  test.assertEqual $ "NYC" "get command - nested path failed"
enddo

clear
do
  get $user "address.zip"
  test.assertEqual $ 10001 "get command - nested path with number failed"
enddo

# Test get with non-existent path
clear
do
  get $user "nonexistent"
  test.assertEqual $ null "get command - non-existent path should return null"
enddo

clear
do
  get $user "address.nonexistent"
  test.assertEqual $ null "get command - nested non-existent path should return null"
enddo

# Test get with empty path
clear
do
  get $user ""
  test.assertEqual $ null "get command - empty path should return null"
enddo

# Test get with object literal
clear
do
  get {name: "Alice", age: 25} "name"
  test.assertEqual $ "Alice" "get command - object literal failed"
enddo

# Test get with variable object
$testObj = {key1: "value1", key2: {nested: "nestedValue"}}
clear
do
  get $testObj "key1"
  test.assertEqual $ "value1" "get command - variable object failed"
enddo

clear
do
  get $testObj "key2.nested"
  test.assertEqual $ "nestedValue" "get command - variable object nested path failed"
enddo

# Test get with null object (should throw error)
# Note: This is tested manually as it throws an error

# Test get with array (should throw error for non-object)
# Note: This is tested manually as it throws an error

log "Test 29a - get command (built-in): All passed"

# Test 30: empty command
$toEmpty = "not empty"
test.assertEqual $toEmpty "not empty" "Variable before empty failed"
empty $toEmpty
test.assertEqual $toEmpty null "empty command failed"
$toEmpty = 42
test.assertEqual $toEmpty 42 "Variable reassignment after empty failed"
empty $toEmpty
test.assertEqual $toEmpty null "empty command second time failed"
$toEmpty = range 1 5
clear
do
  array.length $toEmpty
  test.assertEqual $ 5 "Array before empty failed"
enddo
empty $toEmpty
test.assertEqual $toEmpty null "empty command with array failed"
log "Test 30 - empty command: All passed"

# Test 30b: fallback command
$maybeEmpty = null
clear
do
  fallback $maybeEmpty "default value"
  test.assertEqual $ "default value" "fallback with null failed"
enddo

$maybeEmpty = ""
clear
do
  fallback $maybeEmpty "default string"
  test.assertEqual $ "default string" "fallback with empty string failed"
enddo

$maybeEmpty = null
clear
do
  fallback $maybeEmpty 42
  test.assertEqual $ 42 "fallback with number failed"
enddo

$maybeEmpty = null
clear
do
  fallback $maybeEmpty true
  test.assertEqual $ true "fallback with boolean failed"
enddo

json.parse '[]'
$maybeEmpty = $
clear
do
  fallback $maybeEmpty "fallback for empty array"
  test.assertEqual $ "fallback for empty array" "fallback with empty array failed"
enddo

$maybeEmpty = "not empty"
clear
do
  fallback $maybeEmpty "fallback"
  test.assertEqual $ "not empty" "fallback should not use fallback when value is not empty"
enddo

$maybeEmpty = 0
clear
do
  fallback $maybeEmpty "fallback"
  test.assertEqual $ 0 "fallback should not use fallback for zero"
enddo

$maybeEmpty = false
clear
do
  fallback $maybeEmpty "fallback"
  test.assertEqual $ false "fallback should not use fallback for false"
enddo

$maybeEmpty = null
clear
do
  fallback $maybeEmpty
  test.assertEqual $ null "fallback without fallback value should return null"
enddo

$hasValue = "Alice"
clear
do
  fallback $hasValue "Unknown"
  test.assertEqual $ "Alice" "fallback should return variable value when not empty"
enddo
log "Test 30b - fallback command: All passed"

# Test 31: Comparison functions (isEqual, isBigger, isSmaller, isEqualOrBigger, isEqualOrSmaller)
# Test isEqual
test.isEqual 5 5
test.assertTrue $ "isEqual with equal numbers failed"
test.isEqual 5 3
test.assertFalse $ "isEqual with different numbers failed"
test.isEqual "hello" "hello"
test.assertTrue $ "isEqual with equal strings failed"
test.isEqual "hello" "world"
test.assertFalse $ "isEqual with different strings failed"
test.isEqual true true
test.assertTrue $ "isEqual with equal booleans failed"
test.isEqual true false
test.assertFalse $ "isEqual with different booleans failed"
test.isEqual null null
test.assertTrue $ "isEqual with null values failed"
$arr1 = range 1 3
$arr2 = range 1 3
test.isEqual $arr1 $arr2
test.assertTrue $ "isEqual with equal arrays failed"
log "Test 31a - isEqual: All passed"

# Test isBigger
test.isBigger 10 5
test.assertTrue $ "isBigger with 10 > 5 failed"
test.isBigger 5 10
test.assertFalse $ "isBigger with 5 > 10 failed"
test.isBigger 5 5
test.assertFalse $ "isBigger with 5 > 5 failed"
test.isBigger -5 -10
test.assertTrue $ "isBigger with negative numbers failed"
log "Test 31b - isBigger: All passed"

# Test isSmaller
test.isSmaller 3 5
test.assertTrue $ "isSmaller with 3 < 5 failed"
test.isSmaller 5 3
test.assertFalse $ "isSmaller with 5 < 3 failed"
test.isSmaller 5 5
test.assertFalse $ "isSmaller with 5 < 5 failed"
test.isSmaller -10 -5
test.assertTrue $ "isSmaller with negative numbers failed"
log "Test 31c - isSmaller: All passed"

# Test isEqualOrBigger
test.isEqualOrBigger 10 5
test.assertTrue $ "isEqualOrBigger with 10 >= 5 failed"
test.isEqualOrBigger 5 5
test.assertTrue $ "isEqualOrBigger with 5 >= 5 failed"
test.isEqualOrBigger 3 5
test.assertFalse $ "isEqualOrBigger with 3 >= 5 failed"
test.isEqualOrBigger -5 -10
test.assertTrue $ "isEqualOrBigger with negative numbers failed"
log "Test 31d - isEqualOrBigger: All passed"

# Test isEqualOrSmaller
test.isEqualOrSmaller 3 5
test.assertTrue $ "isEqualOrSmaller with 3 <= 5 failed"
test.isEqualOrSmaller 5 5
test.assertTrue $ "isEqualOrSmaller with 5 <= 5 failed"
test.isEqualOrSmaller 10 5
test.assertFalse $ "isEqualOrSmaller with 10 <= 5 failed"
test.isEqualOrSmaller -10 -5
test.assertTrue $ "isEqualOrSmaller with negative numbers failed"
log "Test 31e - isEqualOrSmaller: All passed"

# Test comparison functions in conditionals
$value = 10
if $(test.isBigger $value 5)
  $result = "bigger"
else
  $result = "not bigger"
endif
test.assertEqual $result "bigger" "isBigger in conditional failed"

if $(test.isSmaller $value 5)
  $result = "smaller"
else
  $result = "not smaller"
endif
test.assertEqual $result "not smaller" "isSmaller in conditional failed"

if $(test.isEqual $value 10)
  $result = "equal"
else
  $result = "not equal"
endif
test.assertEqual $result "equal" "isEqual in conditional failed"

if $(test.isEqualOrBigger $value 10)
  $result = "equal or bigger"
else
  $result = "not equal or bigger"
endif
test.assertEqual $result "equal or bigger" "isEqualOrBigger in conditional failed"

if $(test.isEqualOrSmaller $value 10)
  $result = "equal or smaller"
else
  $result = "not equal or smaller"
endif
test.assertEqual $result "equal or smaller" "isEqualOrSmaller in conditional failed"
log "Test 31f - Comparison functions in conditionals: All passed"

log "Test 31 - Comparison functions: All passed"

# Test 32: Subexpressions $( )
# Test basic single-line subexpression
$test1 = $(math.add 5 3)
test.assertEqual $test1 8 "Basic subexpression failed"

# Test subexpression with multiple operations
$test2 = $(math.add 10 5)
$test3 = $(math.multiply $test2 2)
test.assertEqual $test3 30 "Subexpression with variable reference failed"

# Test nested subexpressions
$test4 = $(math.add $(math.multiply 2 3) $(math.add 1 1))
test.assertEqual $test4 8 "Nested subexpression failed"

# Test multi-line subexpression
$test5 = $(
  math.add 10 20
)
test.assertEqual $test5 30 "Multi-line subexpression failed"

# Test multi-line subexpression with nested subexpression
# Note: $test2 is 15 at this point. The nested subexpression $(set $test2 1) 
# sets $test2 to 1 and returns 1, but $test2 is evaluated first (as 15) before 
# the nested subexpression runs, so result is 15 * 1 = 15
$test6 = $(
  math.multiply $test2 $(set $test2 1)
)

test.assertEqual $test6 15 "Multi-line subexpression with nested subexpression failed"
test.assertEqual $test2 1 "Nested set in subexpression failed"

# Test complex multi-line subexpression
$test7 = $(
  math.add 5 5
  math.multiply $ 3
)
test.assertEqual $test7 30 "Complex multi-line subexpression failed"

# Test subexpression in function call
clear
do
  math.add $(math.multiply 2 5) $(math.add 3 2)
  test.assertEqual $ 15 "Subexpression in function call failed"
enddo

# Test subexpression in conditional
if $(math.add 5 5) == 10
  $test8 = "passed"
else
  $test8 = "failed"
endif

test.assertEqual $test8 "passed" "Subexpression in conditional failed"

# Test subexpression with string operations
$test9 = $(string.concat "hello" " " "world")
test.assertEqual $test9 "hello world" "Subexpression with string operations failed"

# Test subexpression with array operations
$test10 = $(array.create 1 2 3)
clear
do
  array.length $test10
  test.assertEqual $ 3 "Subexpression with array operations failed"
enddo

# Test deeply nested subexpressions
$test11 = $(math.add $(math.multiply $(math.add 1 1) 2) $(math.add 1 1))
test.assertEqual $test11 6 "Deeply nested subexpression failed"

# Test subexpression with return value
def test_subexpr_return
  return $(math.add 10 20)
enddef
clear
do
  test_subexpr_return
  test.assertEqual $ 30 "Subexpression in return statement failed"
enddo

# Test multi-line subexpression with multiple statements
$test12 = $(
  math.add 1 2
  math.multiply $ 2
  math.add $ 1
)
test.assertEqual $test12 7 "Multi-line subexpression with multiple statements failed"

# Test subexpression with variable assignment inside (modifies parent do)
$testVar = 10  # Set initial value in parent do
$test13 = $(
  set $testVar 42  # This should modify the parent $testVar
  math.add $testVar 8
)

test.assertEqual $test13 50 "Subexpression with variable assignment failed"
test.assertEqual $testVar 42 "Variable assignment in subexpression should modify parent do"

log "Test 32 - Subexpressions $( ): All passed"

# Test 33: Attribute access and array indexing
# Test basic property access
json.parse '{"name": "John", "age": 30, "address": {"city": "NYC", "zip": 10001}}'
$user = $
test.assertEqual $user.name "John" "Basic property access failed"
test.assertEqual $user.age 30 "Basic property access with number failed"
test.assertEqual $user.address.city "NYC" "Nested property access failed"
test.assertEqual $user.address.zip 10001 "Nested property access with number failed"

# Test array indexing
$arr = range 10 15
test.assertEqual $arr[0] 10 "Array index 0 failed"
test.assertEqual $arr[2] 12 "Array index 2 failed"
test.assertEqual $arr[5] 15 "Array index 5 failed"
test.assertEqual $arr[10] null "Out of bounds array access should return null"

# Test combined property and array access
json.parse '{"items": [{"name": "item1", "price": 10}, {"name": "item2", "price": 20}]}'
$data = $
test.assertEqual $data.items[0].name "item1" "Combined property and array access failed"
test.assertEqual $data.items[0].price 10 "Combined property and array access with number failed"
test.assertEqual $data.items[1].name "item2" "Combined property and array access second item failed"

# Test property access in expressions
if $user.age >= 30
  $isAdult = true
else
  $isAdult = false
endif
test.assertEqual $isAdult true "Property access in conditional expression failed"

# Test array access in expressions
if $arr[0] == 10
  $firstIsTen = true
else
  $firstIsTen = false
endif
test.assertEqual $firstIsTen true "Array access in conditional expression failed"

# Test property access in function calls
clear
do
  math.add $user.age 5
  test.assertEqual $ 35 "Property access as function argument failed"
enddo

# Test array access in function calls
clear
do
  math.add $arr[0] $arr[1]
  test.assertEqual $ 21 "Array access as function arguments failed"
enddo

# Note: Error cases (accessing property of null, indexing non-array, etc.) are tested manually
# as they throw exceptions that would terminate test execution

# Test property access in variable assignment
$name = $user.name
test.assertEqual $name "John" "Property access in variable assignment failed"

# Test array access in variable assignment
$firstItem = $arr[0]
test.assertEqual $firstItem 10 "Array access in variable assignment failed"

# Test nested property access in variable assignment
$city = $user.address.city
test.assertEqual $city "NYC" "Nested property access in variable assignment failed"

# Test combined access in variable assignment
$itemName = $data.items[0].name
test.assertEqual $itemName "item1" "Combined access in variable assignment failed"

log "Test 33 - Attribute access and array indexing: All passed"

# Test 34: Assignment to attribute paths and array indices
# Test assignment to property path
json.parse '{"name": "John", "age": 30}'
$user = $
$user.city = "London"
test.assertEqual $user.city "London" "Assignment to property path failed"
test.assertEqual $user.name "John" "Assignment to property path should preserve other properties"

# Test assignment to nested property path
$user.address.city = "NYC"
test.assertEqual $user.address.city "NYC" "Assignment to nested property path failed"
test.assertEqual $user.name "John" "Assignment to nested property path should preserve other properties"

# Test assignment to array index
$arr = range 1 5
$arr[0] = 100
test.assertEqual $arr[0] 100 "Assignment to array index failed"
test.assertEqual $arr[1] 2 "Assignment to array index should preserve other elements"

# Test assignment to nested array index
json.parse '{"items": [10, 20, 30]}'
$data = $
$data.items[0] = 100
test.assertEqual $data.items[0] 100 "Assignment to nested array index failed"
test.assertEqual $data.items[1] 20 "Assignment to nested array index should preserve other elements"

# Test assignment to combined path
json.parse '{"items": [{"name": "item1", "price": 10}]}'
$data = $
$data.items[0].price = 50
test.assertEqual $data.items[0].price 50 "Assignment to combined path failed"
test.assertEqual $data.items[0].name "item1" "Assignment to combined path should preserve other properties"

# Test assignment creates intermediate objects
$animal.cat = 5
test.assertEqual $animal.cat 5 "Assignment creating intermediate object failed"

# Test assignment creates nested intermediate objects
$config.database.host = "localhost"
test.assertEqual $config.database.host "localhost" "Assignment creating nested intermediate objects failed"

# Test assignment to last value with property path
json.parse '{"name": "John"}'
$.age = 30

do 
  test.assertEqual $.name "John" "Last value property access failed"
enddo

do
  test.assertEqual $.age 30 "Assignment to last value property path failed"
enddo

test.assertEqual $.name "John" "Assignment to last value property path should preserve other properties"

# Test assignment to last value with array index
range 1 5
$[0] = 100

do
  test.assertEqual $[0] 100 "Assignment to last value array index failed"
enddo

do
  test.assertEqual $[1] 2 "Assignment to last value array index should preserve other elements"
enddo

# Test assignment to last value with nested path
json.parse '{"user": {"name": "John"}}'
$.user.city = "Paris"
do
  test.assertEqual $.user.city "Paris" "Assignment to last value nested path failed"
enddo

do
  test.assertEqual $.user.name "John" "Assignment to last value nested path should preserve other properties"
enddo

# Test assignment to last value creates intermediate objects
json.parse '{}'
$.settings.theme = "dark"

do
  test.assertEqual $.settings.theme "dark" "Assignment to last value creating intermediate object failed"
enddo

# Test assignment to array index out of bounds (should extend array)
$arr = range 1 3
$arr[5] = 100
test.assertEqual $arr[5] 100 "Assignment to out of bounds array index failed"
clear
do
  array.length $arr
  test.assertEqual $ 6 "Assignment to out of bounds array index should extend array"
enddo

# Test assignment to new property on existing object
$user = $parsed
$user.email = "john@example.com"
test.assertEqual $user.email "john@example.com" "Assignment to new property on existing object failed"
test.assertEqual $user.name "John" "Assignment to new property should preserve existing properties"

# Test assignment overwrites existing property
$user.age = 25
test.assertEqual $user.age 25 "Assignment overwriting existing property failed"

# Test assignment to multiple nested paths
$config.api.url = "https://api.example.com"
$config.api.timeout = 30
test.assertEqual $config.api.url "https://api.example.com" "Multiple assignments to nested path failed"
test.assertEqual $config.api.timeout 30 "Multiple assignments to nested path second property failed"

# Test assignment with set command to attribute path
set $user.city "Tokyo"
test.assertEqual $user.city "Tokyo" "set command with attribute path failed"

# Test assignment with set command to array index
set $arr[0] 200
test.assertEqual $arr[0] 200 "set command with array index failed"

# Test assignment with set command to last value attribute path
json.parse '{"name": "Alice"}'
$
set $.age 25
test.assertEqual $.age 25 "set command with last value attribute path failed"

log "Test 34 - Assignment to attribute paths and array indices: All passed"

# Test 35: Break statement in for loops
# Test basic break
$breakTest = 0
for $i in range 1 10
  if $i == 5
    break
  endif
  set $breakTest $i
endfor
test.assertEqual $breakTest 4 "Basic break statement failed"

# Test break in nested loops (should only break inner loop)
$outerCount = 0
$innerCount = 0
for $i in range 1 3
  set $outerCount $i
  for $j in range 1 5
    if $j == 3
      break
    endif
    set $innerCount $j
  endfor
endfor
test.assertEqual $outerCount 3 "Break in nested loop - outer loop failed"
test.assertEqual $innerCount 2 "Break in nested loop - inner loop failed"

# Test break with condition
$found = false
for $i in range 1 10
  if $i == 7
    set $found true
    break
  endif
endfor
test.assertEqual $found true "Break with condition failed"

# Test break early in loop
$earlyBreak = 0
for $i in range 1 10
  if $i == 1
    break
  endif
  set $earlyBreak $i
endfor
test.assertEqual $earlyBreak 0 "Early break failed"

# Test break after some iterations
$iterations = 0
for $i in range 1 10
  set $iterations $i
  if $i == 3
    break
  endif
endfor
test.assertEqual $iterations 3 "Break after iterations failed"

# Test break preserves last value

clear
do
  for $i in range 1 5
    if $i == 3
      break
    endif
  endfor
  test.assertEqual $ 3 "Break preserves last value failed"
enddo

log "Test 35 - Break statement: All passed"

# Test 36: Range with step parameter
# Test positive step counting up
range 0 5 1
$range1 = $
test.assertEqual $range1[0] 0 "Range with step 1 - first element failed"
test.assertEqual $range1[5] 5 "Range with step 1 - last element failed"
clear
do
  array.length $range1
  test.assertEqual $ 6 "Range with step 1 - length failed"
enddo

# Test positive step counting up with larger step
range 0 10 2
$range2 = $
test.assertEqual $range2[0] 0 "Range with step 2 - first element failed"
test.assertEqual $range2[1] 2 "Range with step 2 - second element failed"
test.assertEqual $range2[5] 10 "Range with step 2 - last element failed"
clear
do
  array.length $range2
  test.assertEqual $ 6 "Range with step 2 - length failed"
enddo

# Test negative step counting down
range 5 0 -1
$range3 = $
test.assertEqual $range3[0] 5 "Range with step -1 - first element failed"
test.assertEqual $range3[5] 0 "Range with step -1 - last element failed"
clear
do
  array.length $range3
  test.assertEqual $ 6 "Range with step -1 - length failed"
enddo

# Test negative step counting down with larger step
range 10 0 -2
$range4 = $
test.assertEqual $range4[0] 10 "Range with step -2 - first element failed"
test.assertEqual $range4[1] 8 "Range with step -2 - second element failed"
test.assertEqual $range4[5] 0 "Range with step -2 - last element failed"
clear
do
  array.length $range4
  test.assertEqual $ 6 "Range with step -2 - length failed"
enddo

# Test range with step when start > end (positive step should produce empty or count down)
# Note: With positive step and start > end, the loop condition i <= end is false from start, so empty array
range 5 0 1
$range5 = $
clear
do
  array.length $range5
  test.assertEqual $ 0 "Range 5 0 1 should produce empty array (positive step can't count down)"
enddo

# Test range with step when start < end (negative step should produce empty)
range 0 5 -1
$range6 = $
clear
do
  array.length $range6
  test.assertEqual $ 0 "Range 0 5 -1 should produce empty array (negative step can't count up)"
enddo

# Test range with negative numbers
range -5 0 1
$range7 = $
test.assertEqual $range7[0] -5 "Range -5 0 1 - first element failed"
test.assertEqual $range7[5] 0 "Range -5 0 1 - last element failed"
clear
do
  array.length $range7
  test.assertEqual $ 6 "Range -5 0 1 - length failed"
enddo

# Test range with negative step and negative numbers
range 0 -5 -1
$range8 = $
test.assertEqual $range8[0] 0 "Range 0 -5 -1 - first element failed"
test.assertEqual $range8[5] -5 "Range 0 -5 -1 - last element failed"
clear
do
  array.length $range8
  test.assertEqual $ 6 "Range 0 -5 -1 - length failed"
enddo

log "Test 36 - Range with step parameter: All passed"

# Test 37: Parenthesized function call syntax
# Test basic one-line parenthesized call with positional arguments
clear
do
  math.add(5 10)
  test.assertEqual $ 15 "Parenthesized call - basic positional args failed"
enddo

# Test parenthesized call with named arguments (if supported by function)
# Note: Most builtin functions don't support named args, but syntax should parse correctly
log("test message")
test.assertNull $ "Parenthesized call - log with positional arg failed"

# Test multi-line parenthesized call
clear
do
  math.add(
    10
    20
  )
  test.assertEqual $ 30 "Parenthesized call - multi-line positional args failed"
enddo

# Test parenthesized call with mixed types
array(1 2 3)
$arrFromParen = $
clear
do
  array.length $arrFromParen
  test.assertEqual $ 3 "Parenthesized call - array creation failed"
enddo
test.assertEqual $arrFromParen[0] 1 "Parenthesized call - array element access failed"

# Test parenthesized call with variables
$val1 = 5
$val2 = 7
clear
do
  math.multiply($val1 $val2)
  test.assertEqual $ 35 "Parenthesized call - with variables failed"
enddo

# Test parenthesized call with expressions
clear
do
  math.add(
    $(math.multiply 2 3)
    $(math.add 1 1)
  )
  test.assertEqual $ 8 "Parenthesized call - with subexpressions failed"
enddo

# Test nested parenthesized calls
clear
do
  math.add(
    $(math.multiply(2 3))
    $(math.add(1 1))
  )
  test.assertEqual $ 8 "Parenthesized call - nested calls failed"
enddo

# Test parenthesized call with strings
clear
do
  string.concat("hello" " " "world")
  test.assertEqual $ "hello world" "Parenthesized call - with strings failed"
enddo

# Test parenthesized call with empty arguments
array()
$emptyFromParen = $
clear
do
  array.length $emptyFromParen
  test.assertEqual $ 0 "Parenthesized call - empty args failed"
enddo

# Test parenthesized call with single argument
clear
do
  math.abs(-42)
  test.assertEqual $ 42 "Parenthesized call - single arg failed"
enddo

# Test parenthesized call with module functions
clear
do
  math.add(10 5)
  test.assertEqual $ 15 "Parenthesized call - module function failed"
enddo

clear
do
  string.length("test")
  test.assertEqual $ 4 "Parenthesized call - string module function failed"
enddo

# Test multi-line parenthesized call with module prefix
clear
do
  math.multiply(
    6
    7
  )
  test.assertEqual $ 42 "Parenthesized call - multi-line module function failed"
enddo

clear
do
  math.add(
    10
    20
    30
  )
  test.assertEqual $ 60 "Parenthesized call - multi-line module function with 3 args failed"
enddo

clear
do
  string.concat(
    "hello"
    " "
    "world"
  )
  test.assertEqual $ "hello world" "Parenthesized call - multi-line string module function failed"
enddo

# Test parenthesized call in assignment
math.add(100 200)
$result = $
test.assertEqual $result 300 "Parenthesized call - in assignment failed"

# Test parenthesized call with last value
clear
do
  math.add(5 5)
  math.multiply($ 2)
  test.assertEqual $ 20 "Parenthesized call - chaining with last value failed"
enddo

# Test parenthesized call with named arguments syntax
# Note: Most functions don't use named args yet, but syntax should parse
# The named args object will be passed as the last argument
concat("test" key1="value1" key2=42)
test.assertNotNull $ "Parenthesized call - with named args failed"

# Test parenthesized call with mixed positional and named arguments
log("message" verbose=true level="info")
test.assertNotNull $ "Parenthesized call - mixed positional and named args failed"

# Test multi-line parenthesized call with named arguments
log(
  "test message"
  verbose=true
  level="debug"
)
test.assertNotNull $ "Parenthesized call - multi-line with named args failed"

# Test named arguments with expressions
log("test" count=$(math.add 1 2) enabled=true)
test.assertNotNull $ "Parenthesized call - named args with expressions failed"

log "Test 37 - Parenthesized function call syntax: All passed"

# Test 38: Function parameters and arguments
# Test function definition with parameter names
def greetLog $name $age
  log "Hello" $name
  log "Age:" $age
  log "Positional 1:" $1
  log "Positional 2:" $2
enddef

clear
do
  greetLog("Alice" 25)
  log $
  test.assertNull $ "Function with param names - basic call failed"
enddo

# Test parameter name aliases
def add $a $b
  math.add $a $b
enddef

clear
do
  add(10 20)
  test.assertEqual $ 30 "Function param aliases failed"
enddo

# Test that $1, $2 still work
def multiply $x $y
  math.multiply $1 $2
enddef

clear
do
  multiply(5 6)
  test.assertEqual $ 30 "Function positional params via $1 $2 failed"
enddo

# Test function with more args than declared params
def first $a
  log "a:" $a
  log "extra:" $2
enddef

clear
do
  first(10 20)
  test.assertEqual $ null "Function with extra args failed"
enddo

# Test function with fewer args than declared params
def three $a $b $c
  log "a:" $a
  log "b:" $b
  log "c:" $c
enddef

clear
do
  three(10 20)
  test.assertEqual $ null "Function with fewer args failed"
enddo

# Test named arguments
def config $env
  log "env:" $env
  log "key:" $args.key
  log "value:" $args.value
enddef

clear
do
  config("production" key="api-key" value="secret123")
  test.assertEqual $ null "Function with named args failed"
enddo

# Test named arguments in CLI-style call
def test_fn_2 $a $b
  log "a:" $a
  log "b:" $b
  log "flag:" $args.flag
enddef

clear
do
  test_fn_2 "hello" "world" flag=true
  test.assertEqual $ null "Function CLI-style with named args failed"
enddo

# Test mixed positional and named arguments
def deploy $env
  log "env:" $env
  log "replicas:" $args.replicas
  log "timeout:" $args.timeout
enddef

clear
do
  deploy("staging" replicas=3 timeout=30)
  test.assertEqual $ null "Function mixed args failed"
enddo

# Test function without parameter names (only $1, $2)
def simple
  log "first:" $1
  log "second:" $2
enddef

clear
do
  simple("hello" "world")
  test.assertEqual $ null "Function without param names failed"
enddo

# Test $args access
def get_args
  log "key1:" $args.key1
  log "key2:" $args.key2
enddef

clear
do
  get_args(key1="value1" key2="value2")
  test.assertEqual $ null "Function $args access failed"
enddo

# Test parameter name collision (param name same as named arg)
def collision $key
  log "param key:" $key
  log "named key:" $args.key
enddef

clear
do
  collision("positional" key="named")
  test.assertEqual $ null "Function param/named arg collision failed"
enddo

log "Test 38 - Function parameters and arguments: All passed"

# Test 39: Backslash line continuation
log "Test 39 - Backslash line continuation"

# Test 39a: Simple continuation
log "this is a very long message " \
    "that continues on the next line"

# Test 39b: Multiple continuations
$long = "hello " \
        "world " \
        "from RobinPath"
log "Test 39b - Long string:" $long

# Test 39c: Function call with continuation
def test_continuation
  log "Received:" $1 $2 $3
enddef

test_continuation "first" \
                 "second" \
                 "third"

# Test 39d: Assignment with continuation
$query = "SELECT * FROM users " \
         "WHERE active = 1 " \
         "ORDER BY created_at DESC"
log "Test 39d - Query:" $query

# Test 39e: Parenthesized function call with continuation
def multi_args
  log "Args:" $1 $2 $args.key1 $args.key2
enddef

multi_args("arg1" "arg2" \
           key1="value1" \
           key2="value2")

# Test 39f: If condition with continuation
$a = 5
$b = 3
$c = "ok"
if $a > 0 && \
   $b < 10 && \
   $c == "ok"
  log "Test 39f - Conditions met"
endif

log "Test 39 - Backslash line continuation: All passed"

# Test 40: tag command
log "Test 40 - tag command"

# Test 40a: Basic tag usage
clear
do
  tag "function" "calculateTotal" "Calculates the total price"
  test.assertEqual $ null "tag command should return null"
enddo

# Test 40b: Tag with different types
clear
do
  tag "variable" "userCount" "Number of active users"
  test.assertEqual $ null "tag command with variable type failed"
enddo

clear
do
  tag "module" "payment" "Payment processing module"
  test.assertEqual $ null "tag command with module type failed"
enddo

# Test 40c: Tag with long descriptions
clear
do
  tag "function" "processData" "This function processes user data and returns formatted results"
  test.assertEqual $ null "tag command with long description failed"
enddo

# Test 40d: Tag should not affect execution
$beforeTag = 42
tag "test" "value" "Test description"
$afterTag = 42
test.assertEqual $beforeTag $afterTag "tag command should not affect variables"
test.assertEqual $afterTag 42 "tag command should not affect execution"

log "Test 40 - tag command: All passed"

# Test 41: meta command
log "Test 41 - meta command"

# Test 41a: Meta for variables
$testVar = 100
clear
do
  meta $testVar description "A variable to store test values"
  test.assertEqual $ null "meta command should return null"
  test.assertEqual $testVar 100 "meta command should not affect variable value"
enddo

# Test 41b: Meta for functions
def test_function
  log "Test function"
enddef

clear
do
  meta test_function description "A test function for demonstration"
  test.assertEqual $ null "meta command for function should return null"
enddo

clear
do
  # Test 41c: Multiple metadata entries for same variable
  meta $testVar version 5
  test.assertEqual $ null "meta command with number value failed"
enddo

clear
do
  meta $testVar author "Test Author"
  test.assertEqual $ null "meta command with string value failed"
enddo

clear
do
  meta $testVar enabled true
  test.assertEqual $ null "meta command with boolean value failed"
enddo

# Test 41d: Multiple metadata entries for same function
clear
do
  meta test_function version 1
  test.assertEqual $ null "meta command for function with version failed"
enddo

clear
do
  meta test_function category "utility"
  test.assertEqual $ null "meta command for function with category failed"
enddo

# Test 41e: Meta should not affect execution
$beforeMeta = 50
meta $beforeMeta description "Test variable"
$afterMeta = 50
test.assertEqual $beforeMeta $afterMeta "meta command should not affect variables"
test.assertEqual $afterMeta 50 "meta command should not affect execution"

# Test 41f: Meta with different value types
$metaTest = "test"
meta $metaTest count 42
meta $metaTest active true
meta $metaTest data null
test.assertEqual $metaTest "test" "meta command should not affect variable value"

# Test 41g: Meta for function with different metadata keys
def another_function
  return 42
enddef

meta another_function description "Another test function"
meta another_function returnType "number"
meta another_function example "another_function()"
clear
do
  test.assertEqual $ null "meta command for function with multiple keys failed"
enddo

# Test 41h: Meta should work with existing variables
$existingVar = "hello"
meta $existingVar description "An existing variable"
test.assertEqual $existingVar "hello" "meta command should not modify existing variable"

# Test 41i: Meta should work with existing functions
def existing_fn
  log "existing"
enddef

meta existing_fn description "An existing function"
clear
do
  test.assertEqual $ null "meta command for existing function failed"
enddo

log "Test 41 - meta command: All passed"

# Test 42: getMeta command
log "Test 42 - getMeta command"

# Test 42a: getMeta for variables - return all metadata
$testVar = 100
meta $testVar description "A variable to store test values"
meta $testVar version 5
meta $testVar author "Test Author"

getMeta $testVar
$allMeta = $
test.assertType $allMeta "object" "getMeta should return an object"
test.assertEqual $allMeta.description "A variable to store test values" "getMeta all metadata - description failed"
test.assertEqual $allMeta.version 5 "getMeta all metadata - version failed"
test.assertEqual $allMeta.author "Test Author" "getMeta all metadata - author failed"

# Test 42b: getMeta for variables - return specific key
clear
do
  getMeta $testVar description
  test.assertEqual $ "A variable to store test values" "getMeta specific key - description failed"
enddo

clear
do
  getMeta $testVar version
  test.assertEqual $ 5 "getMeta specific key - version failed"
enddo

clear
do
  getMeta $testVar nonexistent
  test.assertEqual $ null "getMeta nonexistent key should return null"
enddo

# Test 42c: getMeta for functions - return all metadata
def test_function_meta
  log "Test function"
enddef

meta test_function_meta description "A test function for demonstration"
meta test_function_meta version 1
meta test_function_meta category "utility"

getMeta test_function_meta
$funcMeta = $
test.assertType $funcMeta "object" "getMeta for function should return an object"
test.assertEqual $funcMeta.description "A test function for demonstration" "getMeta function all metadata - description failed"
test.assertEqual $funcMeta.version 1 "getMeta function all metadata - version failed"
test.assertEqual $funcMeta.category "utility" "getMeta function all metadata - category failed"

# Test 42d: getMeta for functions - return specific key
clear
do
  getMeta test_function description
  test.assertEqual $ "A test function for demonstration" "getMeta function specific key - description failed"
enddo

clear
do
  getMeta test_function version
  test.assertEqual $ 1 "getMeta function specific key - version failed"
enddo

clear
do
  getMeta test_function nonexistent
  test.assertEqual $ null "getMeta function nonexistent key should return null"
enddo

# Test 42f: getMeta for function with no metadata
def no_meta_fn
  return 42
enddef

getMeta no_meta_fn
$emptyfuncmeta = $
test.assertNull $emptyfuncmeta "getMeta for function with no metadata should return null"

# Test 42g: getMeta preserves value types
$typeTest = "test"
meta $typeTest count 42
meta $typeTest active true
meta $typeTest data null

clear
do
  getMeta $typeTest count
  test.assertEqual $ 42 "getMeta should preserve number type"
enddo

clear
do
  getMeta $typeTest active
  test.assertEqual $ true "getMeta should preserve boolean type"
enddo

clear
do
  getMeta $typeTest data
  test.assertEqual $ null "getMeta should preserve null type"
enddo

log "Test 42 - getMeta command: All passed"

# Test 43: clear command
log "Test 43 - clear command"

# Test 43a: Basic clear - clears last value
clear
do
  math.add 10 20
  test.assertEqual $ 30 "Last value before clear failed"
enddo
clear
do
  test.assertEqual $ null "clear command failed to clear last value"
enddo

# Test 43b: Clear after multiple operations
clear
do
  math.add 5 5
  math.multiply $ 2
  test.assertEqual $ 20 "Last value before clear (chained) failed"
enddo
clear
do
  test.assertEqual $ null "clear command failed after chained operations"
enddo

# Test 43c: Clear with no previous value
clear
do
  test.assertEqual $ null "clear command should set null even with no previous value"
enddo

# Test 43d: Clear doesn't affect variables
$testVar = 42
math.add 10 20
clear
test.assertEqual $testVar 42 "clear command should not affect variables"
clear
do
  test.assertEqual $ null "clear command should clear last value"
enddo

# Test 43e: Clear after function call
def return_value_clear_test
  return 100
enddef

clear
return_value_clear_test
do
  test.assertEqual $ 100 "Function return before clear failed"
enddo
clear
do
  test.assertEqual $ null "clear command failed after function call"
enddo

# Test 43f: Clear can be used multiple times
clear
do
  math.add 1 1
  clear
  clear
  test.assertEqual $ null "Multiple clear commands should work"
enddo

log "Test 43 - clear command: All passed"

# Test 44: forget command
log "Test 44 - forget command"

# Test 44a: Forget a variable in current do
$testVar = 100
clear
do
  forget $testVar
  test.assertEqual $ null "forget command should return null"
  test.assertEqual $testVar null "forgotten variable should return null"
enddo
# Variable should be accessible again after do ends
test.assertEqual $testVar 100 "forgotten variable should be accessible after do ends"

# Test 44b: Forget a function in current do
def test_function_forget
  return 42
enddef

clear
do
  forget test_function_forget
  test.assertEqual $ null "forget function should return null"
  # Note: Calling test_function_forget here would throw an error, so we skip that test
  # and verify it works again after do ends
enddo
# Function should be accessible again after do ends
clear
do
  test_function_forget
  test.assertEqual $ 42 "forgotten function should be accessible after do ends"
enddo

# Test 44c: Forget a built-in command in current do
clear
do
  forget log
  test.assertEqual $ null "forget builtin should return null"
  # Note: Calling log here would throw an error, so we skip that test
  # and verify it works again after do ends
enddo
# Built-in should be accessible again after do ends
log "Test 44c - Built-in accessible after do"

# Test 44d: Forget doesn't affect parent do
$parentVar = 200
clear
do
  forget $parentVar
  test.assertEqual $parentVar null "forgotten variable in do should return null"
enddo
test.assertEqual $parentVar 200 "forgotten variable should not affect parent do"

# Test 44e: Forget doesn't affect child do
$outerVar = 300
clear
do
  forget $outerVar
  clear
  do
    # Child do can still access the variable (forget only affects current do)
    test.assertEqual $outerVar 300 "forgotten variable should be accessible in child do"
  enddo
  test.assertEqual $outerVar null "forgotten variable should still be null in current do"
enddo

# Test 44f: Forget multiple variables
$var1 = 1
$var2 = 2
$var3 = 3
clear
do
  forget $var1
  forget $var2
  test.assertEqual $var1 null "first forgotten variable should return null"
  test.assertEqual $var2 null "second forgotten variable should return null"
  test.assertEqual $var3 3 "non-forgotten variable should still work"
enddo

# Test 44g: Forget module function
clear
do
  forget math.add
  test.assertEqual $ null "forget module function should return null"
  # Note: Calling math.add here would throw an error, so we skip that test
  # and verify it works again after do ends
enddo
# Module function should be accessible again after do ends
clear
do
  math.add 5 5
  test.assertEqual $ 10 "forgotten module function should be accessible after do ends"
enddo

# Test 44h: Forget in nested dos
$nestedVar = 400
clear
do
  forget $nestedVar
  clear
  do
    # Inner do can still access (forget only affects the do where it was called)
    test.assertEqual $nestedVar 400 "forgotten variable should be accessible in nested do"
  enddo
  test.assertEqual $nestedVar null "forgotten variable should still be null in original do"
enddo

# Test 44i: Forget and then use variable in same do (should fail)
$forgetTest = 500
clear
do
  forget $forgetTest
  # Trying to use forgotten variable should return null
  test.assertEqual $forgetTest null "forgotten variable should return null when accessed"
enddo

# Test 44j: Forget function and verify it works after do
def forget_test_fn
  return "hello"
enddef

clear
do
  forget forget_test_fn
  test.assertEqual $ null "forget function should return null"
  # Note: Calling forget_test_fn here would throw an error
enddo
# Function should be accessible again after do ends
clear
do
  forget_test_fn
  test.assertEqual $ "hello" "forgotten function should be accessible after do ends"
enddo

# Test 44k: Forget doesn't affect other variables/functions
$keepVar1 = 10
$keepVar2 = 20
def keep_function
  return 30
enddef

clear
do
  forget $keepVar1
  test.assertEqual $keepVar1 null "forgotten variable should return null"
  test.assertEqual $keepVar2 20 "non-forgotten variable should still work"
  keep_function
  test.assertEqual $ 30 "non-forgotten function should still work"
enddo

log "Test 44 - forget command: All passed"

# Test 45: getType command
log "Test 45 - getType command"

# Test 45a: getType for string
$strVar = "hello"
clear
do
  getType $strVar
  test.assertEqual $ "string" "getType for string failed"
enddo

# Test 45b: getType for number
$numVar = 42
clear
do
  getType $numVar
  test.assertEqual $ "number" "getType for number failed"
enddo

# Test 45c: getType for boolean
$boolVar = true
clear
do
  getType $boolVar
  test.assertEqual $ "boolean" "getType for boolean failed"
enddo

$boolVar2 = false
clear
do
  getType $boolVar2
  test.assertEqual $ "boolean" "getType for false boolean failed"
enddo

# Test 45d: getType for null
$nullVar = null
clear
do
  getType $nullVar
  test.assertEqual $ "null" "getType for null failed"
enddo

# Test 45e: getType for array
$arrVar = range 1 5
clear
do
  getType $arrVar
  test.assertEqual $ "array" "getType for array failed"
enddo

array 1 2 3
$arrVar2 = $
clear
do
  getType $arrVar2
  test.assertEqual $ "array" "getType for array created with array command failed"
enddo

# Test 45f: getType for object
obj '{name: "John", age: 30}'
$objVar = $
clear
do
  getType $objVar
  test.assertEqual $ "object" "getType for object failed"
enddo

json.parse '{"key": "value"}'
$objVar2 = $
clear
do
  getType $objVar2
  test.assertEqual $ "object" "getType for object from json.parse failed"
enddo

# Test 45g: getType for empty object
obj
$emptyObj = $
clear
do
  getType $emptyObj
  test.assertEqual $ "object" "getType for empty object failed"
enddo

# Test 45h: getType for empty array
array
$emptyArr = $
clear
do
  getType $emptyArr
  test.assertEqual $ "array" "getType for empty array failed"
enddo

log "Test 45 - getType command: All passed"

# Test 46: Isolated dos with parameters
log "Test 46 - Isolated dos with parameters"

# Test 46a: Scope without parameters inherits from parent
$parentVar = 100
clear
do
  test.assertEqual $parentVar 100 "Scope without parameters should access parent variables"
  $localVar = 200
  test.assertEqual $localVar 200 "Scope without parameters should allow local variables"
enddo
test.assertEqual $parentVar 100 "Parent variable should be unchanged after do"

# Test 46b: Scope with parameters is isolated
$outerVar = 300
clear
do $a
  # Should not be able to access $outerVar
  test.assertEqual $outerVar null "Isolated do should not access parent variables"
  test.assertEqual $a null "Parameter should be accessible (defaults to null)"
  $localVar = 400
  test.assertEqual $localVar 400 "Isolated do should allow local variables"
enddo
test.assertEqual $outerVar 300 "Parent variable should be unchanged after isolated do"


# Test 46c: Scope with multiple parameters
$globalVar = 500
clear
do $x $y
  test.assertEqual $globalVar null "Isolated do with multiple params should not access parent"
  test.assertEqual $x null "First parameter should be accessible"
  test.assertEqual $y null "Second parameter should be accessible"
  $z = 600
  test.assertEqual $z 600 "Local variable should work in isolated do"
enddo

# Test 46d: Scope with multiple parameters
$anotherVar = 700
clear
do $a $b $c
  test.assertEqual $anotherVar null "Isolated do with multiple params should not access parent"
  test.assertEqual $a null "First parameter should be accessible"
  test.assertEqual $b null "Second parameter should be accessible"
  test.assertEqual $c null "Third parameter should be accessible"
  $localVar = 800
  test.assertEqual $localVar 800 "Local variable should work in isolated do"
enddo


# Test 46e: Nested isolated dos
$nestedOuter = 800
clear
do $a
  test.assertEqual $nestedOuter null "Outer isolated do should not access parent"
  test.assertEqual $a null "Parameter in outer do should be accessible"
  clear
  do $b
    test.assertEqual $nestedOuter null "Inner isolated do should not access grandparent"
    test.assertEqual $a null "Inner isolated do should not access outer do parameter"
    test.assertEqual $b null "Parameter in inner do should be accessible"
    $innerVar = 900
    test.assertEqual $innerVar 900 "Inner do local variable should work"
  enddo
  test.assertEqual $a null "Outer do parameter should still be accessible"
enddo


# Test 46f: Variables created in isolated block do not leak to parent
clear
do $x
  $isolatedVar = 1000
  test.assertEqual $isolatedVar 1000 "Variable in isolated do should work"
enddo
test.assertEqual $isolatedVar null "Variable from isolated do should not be accessible in parent"


# Test 46g: Isolated do can use declared parameters
clear
do $value
  set $value 42
  test.assertEqual $value 42 "Isolated do should be able to set parameter values"
  math.add $value 8
  test.assertEqual $ 50 "Isolated do should be able to use parameters in operations"
enddo


log "Test 46 - Isolated dos with parameters: All passed"

# Test that def blocks are extracted first, so functions can reference each other
# regardless of order in the code

# After all def blocks are extracted, fn should be callable
# and it should be able to call fn2 and fn3 even though they're defined after

# Test 48: Def blocks extracted first and stored separately
log "Test 48 - Def blocks extracted first!"


do
  log "hello"
enddo

clear
do
  fn
  test.assertEqual $ 30 "Def blocks extracted first - fn should be able to call fn2 and fn3"
enddo

# Test that fn2 and fn3 are also callable directly
clear
do
  fn2
  test.assertEqual $ 10 "Def blocks extracted first - fn2 should be callable"
enddo

clear
do
  fn3
  test.assertEqual $ 20 "Def blocks extracted first - fn3 should be callable"
enddo


def fn
  fn2
  $result1 = $
  fn3
  $result2 = $
  math.add $result1 $result2
enddef

def fn2
  return 10
enddef

def fn3
  return 20
enddef



log "Test 48 - Def blocks extracted first: All passed"

# Test 49: Comment attachment and AST nodes
log "Test 49 - Comment attachment and AST nodes"

# Test 49a: Comments directly above statement should be attached
# comment 1
# comment 2
math.add 5 3
$test49a = $
test.assertEqual $test49a 8 "Comments directly above statement should be attached"

# Test 49b: Comments separated by blank line should become separate comment nodes
# comment 3

# comment 4
math.add 2 2
$test49b = $
test.assertEqual $test49b 4 "Comments separated by blank line should not be attached"

# Test 49c: Inline comments should be attached
math.add 10 5  # inline comment
$test49c = $
test.assertEqual $test49c 15 "Inline comments should be attached"

# Test 49d: Multiple consecutive comments above statement
# comment 5
# comment 6
# comment 7
log "test"
test.assertNotNull $ "Multiple consecutive comments should be attached"

# Test 49e: Comment with blank line before should be separate node
# comment 8

log "test2"
test.assertNotNull $ "Comment with blank line before should not be attached"

# Test 49f: Comment at end of file (no statement after)
# final comment

log "Test 49 - Comment attachment and AST nodes: All passed"

# Test 50: Code position (codePos) with leading whitespace
log "Test 50 - Code position with leading whitespace"

# Test commands with leading whitespace
  log "test with 2 spaces"
test.assertNotNull $ "Command with 2 leading spaces failed"

    log "test with 4 spaces"
test.assertNotNull $ "Command with 4 leading spaces failed"

# Test assignments with leading whitespace
  $spacedVar = "value with 2 spaces"
test.assertEqual $spacedVar "value with 2 spaces" "Assignment with 2 leading spaces failed"

    $spacedVar2 = 42
test.assertEqual $spacedVar2 42 "Assignment with 4 leading spaces failed"

# Test set command with leading whitespace
  set $spacedVar "new value"
test.assertEqual $spacedVar "new value" "set command with 2 leading spaces failed"

    set $spacedVar2 100
test.assertEqual $spacedVar2 100 "set command with 4 leading spaces failed"

# Test function calls with leading whitespace
  math.add 5 5
test.assertEqual $ 10 "Function call with 2 leading spaces failed"

    math.multiply 3 4
test.assertEqual $ 12 "Function call with 4 leading spaces failed"

# Test nested indentation (inside if block)
if true
    $nestedVar = "nested"
    test.assertEqual $nestedVar "nested" "Nested assignment with indentation failed"
    
    math.add 10 20
    test.assertEqual $ 30 "Nested function call with indentation failed"
endif

# Test nested indentation (inside for loop)
for $i in range 1 3
    $loopVar = $i
    test.assertEqual $loopVar $i "Loop assignment with indentation failed"
endfor

# Test mixed indentation levels
  $var1 = 1
    $var2 = 2
      $var3 = 3
test.assertEqual $var1 1 "Mixed indentation level 1 failed"
test.assertEqual $var2 2 "Mixed indentation level 2 failed"
test.assertEqual $var3 3 "Mixed indentation level 3 failed"

log "Test 50 - Code position with leading whitespace: All passed"

# Test 51: Code position (codePos) excluding inline comments
log "Test 51 - Code position excluding inline comments"

$a = 3    # inline comment
$b = "test"  # another comment
log "hello"  # log comment
math.add 5 10  # math comment

log "Test 51 - Code position excluding inline comments: All passed"

# Test 52: Named arguments with $paramName=value syntax
log "Test 52 - Named arguments with $paramName=value syntax"

# Define function with parameter names
def test_fn $a $b
  string.concat $a $b
enddef

# Test CLI-style: test_fn $a="hello" $b="world"
test_fn $a="hello" $b="world"
test.assertEqual $ "helloworld" "CLI-style $paramName=value failed"

# Test parenthesized: test_fn($a="foo" $b="bar")
test_fn($a="foo" $b="bar")
test.assertEqual $ "foobar" "Parenthesized $paramName=value failed"

# Test multi-line parenthesized
test_fn(
  $a="multi"
  $b="line"
)
test.assertEqual $ "multiline" "Multi-line parenthesized $paramName=value failed"

# Test with mixed positional and named args
def greetConcat $name $age
  string.concat $name " is " $age
enddef

greetConcat "Alice" $age="25"
test.assertEqual $ "Alice is 25" "Mixed positional and named args failed"

# Test with only named args (no positional)
def add_named_args $x $y
  math.add $x $y
enddef

add_named_args($x=10 $y=20)
test.assertEqual $ 30 "Named args only failed"

# Test with spaces around = in parenthesized calls
def test_spaces $a $b
  string.concat $a $b
enddef

test_spaces($a = "hello" $b = "world")
test.assertEqual $ "helloworld" "Spaces around = in parenthesized call failed"

# Test multi-line with spaces around =
test_spaces(
  $a = "multi"
  $b = "line"
)
test.assertEqual $ "multiline" "Multi-line with spaces around = failed"

log "Test 52 - Named arguments with $paramName=value syntax: All passed"

# Test 53: Function call syntaxType preservation
log "Test 53 - Function call syntaxType preservation"

# Define a simple function for testing
def echo $msg
  $msg
enddef

# Test 1: Space-separated syntax: fn 'a' 'b'
echo "space"
log "Test 53.1 - Space-separated syntax executed"

# Test 2: Parenthesized syntax: fn('a' 'b')
echo("parentheses")
log "Test 53.2 - Parenthesized syntax executed"

# Test 3: Named arguments parenthesized: fn($a='a' $b='b')
def test_named $a $b
  string.concat $a $b
enddef

test_named($a="named" $b="args")
log "Test 53.3 - Named arguments parenthesized syntax executed"

# Test 4: Multiline parenthesized: fn(\n  $a='a'\n  $b='b'\n)
test_named(
  $a="multi"
  $b="line"
)
log "Test 53.4 - Multiline parenthesized syntax executed"

log "Test 53 - Function call syntaxType preservation: All passed"

# Test 54: Built-in decorator functionality (@desc/@description, @title)
log "Test 54 - Built-in decorator functionality"

# Test @desc decorator
@desc "A test function with description"
def testDescFn
  log "Test 54.1 - Function with @desc decorator"
enddef

# Call function to trigger decorator execution (decorators execute when function is called)
testDescFn

# Verify description metadata was added
getMeta testDescFn description
test.assertEqual $ "A test function with description" "@desc decorator failed to add description metadata"

# Test @description decorator (alias for @desc)
@description "Another test function"
def testDescriptionFn
  log "Test 54.2 - Function with @description decorator"
enddef

# Call function to trigger decorator execution
testDescriptionFn

# Verify description metadata was added
getMeta testDescriptionFn description
test.assertEqual $ "Another test function" "@description decorator failed to add description metadata"

# Test @title decorator
@title "Test Function Title"
def testTitleFn
  log "Test 54.3 - Function with @title decorator"
enddef

# Call function to trigger decorator execution
testTitleFn

# Verify title metadata was added
getMeta testTitleFn title
test.assertEqual $ "Test Function Title" "@title decorator failed to add title metadata"

# Test multiple decorators on same function
@desc "Function with both description and title"
@title "Multi Decorator Function"
def multiDecoratorFn
  log "Test 54.4 - Function with multiple decorators"
enddef

# Call function to trigger decorator execution
multiDecoratorFn

# Verify both metadata were added
getMeta multiDecoratorFn description
test.assertEqual $ "Function with both description and title" "Multiple decorators - description failed"
getMeta multiDecoratorFn title
test.assertEqual $ "Multi Decorator Function" "Multiple decorators - title failed"

# Test that decorators inside comments are ignored
# @abc "This decorator should be ignored"
# @desc "This should also be ignored"
def testIgnoredDecoratorFn
  log "Test 54.5 - Function with decorators in comments (should be ignored)"
enddef

# Call function to trigger decorator execution
testIgnoredDecoratorFn

# Verify that decorators in comments were NOT applied (no metadata should exist)
getMeta testIgnoredDecoratorFn description
test.assertEqual $ null "Decorator in comment should be ignored - description should not exist"
getMeta testIgnoredDecoratorFn abc
test.assertEqual $ null "Decorator in comment should be ignored - abc metadata should not exist"

log "Test 54 - Built-in decorator functionality: All passed"

# Test 55: has command - check if variable or function exists
log "Test 55 - has command"

# Test has with variables
$testVar = 42
has $testVar
test.assertTrue $ "has command - variable exists failed"

has $nonexistentVar
test.assertFalse $ "has command - nonexistent variable should return false"

# Test has with user-defined functions
def testHasFunc
  log "test"
enddef

has testHasFunc
test.assertTrue $ "has command - user-defined function exists failed"

has nonexistentFunc
test.assertFalse $ "has command - nonexistent function should return false"

# Test has with builtin functions
has log
test.assertTrue $ "has command - builtin function exists failed"

has set
test.assertTrue $ "has command - builtin set function exists failed"

has get
test.assertTrue $ "has command - builtin get function exists failed"

# Test has with module functions
has math.add
test.assertTrue $ "has command - module function exists failed"

has math.multiply
test.assertTrue $ "has command - module function multiply exists failed"

has string.length
test.assertTrue $ "has command - module function string.length exists failed"

has nonexistent.module
test.assertFalse $ "has command - nonexistent module function should return false"

has math.nonexistent
test.assertFalse $ "has command - nonexistent function in module should return false"

# Test has in different scopes
clear
do
  $localVar = 100
  has $localVar
  test.assertTrue $ "has command - local variable in do block failed"
  
  has $testVar
  test.assertTrue $ "has command - outer variable accessible in do block failed"
enddo

has laterDefinedFunc
test.assertTrue $ "has command - function defined after check should return true"

def laterDefinedFunc
  return "defined"
enddef


log "Test 55 - has command: All passed"

# Test 56: into syntax sugar
log "Test 56 - into syntax sugar"

# Test 56a: Basic command with into
add 1 2 into $result56a
test.assertEqual $result56a 3 "into syntax - basic command failed"

# Test 56b: Command with into should not affect last value
math.add 10 20
$beforeInto = $
add 5 5 into $result56b
test.assertEqual $beforeInto 30 "into syntax - should preserve last value before into"
test.assertEqual $result56b 10 "into syntax - basic command result failed"

# Test 56c: Module function with into
math.add 15 25 into $result56c
test.assertEqual $result56c 40 "into syntax - module function failed"

math.multiply 6 7 into $result56c2
test.assertEqual $result56c2 42 "into syntax - module function multiply failed"

# Test 56d: String function with into
string.concat "hello" " " "world" into $result56d
test.assertEqual $result56d "hello world" "into syntax - string function failed"

# Test 56e: Array function with into
array.create 1 2 3 into $result56e
clear
do
  array.length $result56e
  test.assertEqual $ 3 "into syntax - array function length failed"
enddo
test.assertEqual $result56e[0] 1 "into syntax - array function element access failed"

# Test 56f: Do block with into
do into $result56f
  math.add 20 30
  math.multiply $ 2
enddo
test.assertEqual $result56f 100 "into syntax - do block failed"

# Test 56g: Do block with into should not affect last value
math.add 1 1
$beforeDoInto = $
do into $result56g
  math.add 5 5
enddo
test.assertEqual $beforeDoInto 2 "into syntax - do block should preserve last value"
test.assertEqual $result56g 10 "into syntax - do block result failed"

# Test 56g2: Do block with parameters and into
$outerVar56g2 = 300
clear
do $a $b into $result56g2
  # Should not be able to access $outerVar56g2 (isolated scope)
  test.assertEqual $outerVar56g2 null "do with params and into - should not access parent variables"
  test.assertEqual $a null "do with params and into - first param should be accessible"
  test.assertEqual $b null "do with params and into - second param should be accessible"
  # Set values and compute result
  set $a 5
  set $b 3
  math.add $a $b
enddo
test.assertEqual $outerVar56g2 300 "do with params and into - parent variable should be unchanged"
test.assertEqual $result56g2 8 "do with params and into - should return computed result"

# Test 56h: Parenthesized function call with into (single line)
math.add(10 20) into $result56h
test.assertEqual $result56h 30 "into syntax - parenthesized call single line failed"

# Test 56i: Parenthesized function call with into (multiline)
math.add(
  15
  25
) into $result56i
test.assertEqual $result56i 40 "into syntax - parenthesized call multiline failed"

# Test 56j: Parenthesized function call with named arguments and into
def testIntoFn $a $b
  math.add $a $b
enddef

testIntoFn($a=10 $b=20) into $result56j
test.assertEqual $result56j 30 "into syntax - parenthesized call with named args failed"

# Test 56k: Multiline parenthesized call with named arguments and into
testIntoFn(
  $a=5
  $b=15
) into $result56k
test.assertEqual $result56k 20 "into syntax - multiline parenthesized call with named args failed"

# Test 56l: Parenthesized call with into on same line as closing paren
math.multiply(6 7) into $result56l
test.assertEqual $result56l 42 "into syntax - into on same line as closing paren failed"

# Test 56m: Parenthesized call with into on next line
math.add(8 9)
into $result56m
test.assertEqual $result56m 17 "into syntax - into on next line after parenthesized call failed"

# Test 56n: Do block with into
do into $result56n
  math.add 3 4
enddo
test.assertEqual $result56n 7 "into syntax - do block with into failed"

# Test 56o: Do block with into (same syntax as 56n)
do into $result56o
  math.add 2 3
enddo
test.assertEqual $result56o 5 "into syntax - do block with into failed"

# Test 56p: Complex nested operations with into
do into $result56p
  math.add 1 2
  math.multiply $ 3
  math.add $ 1
enddo


test.assertEqual $result56p 10 "into syntax - complex nested operations failed"

# Test 56q: Into with attribute path assignment
json.parse '{"value": 0}'
$obj56q = $
math.add 10 20 into $obj56q.result
test.assertEqual $obj56q.result 30 "into syntax - attribute path assignment failed"
test.assertEqual $obj56q.value 0 "into syntax - attribute path should preserve other properties"

# Test 56r: Into should work with user-defined functions
def addTen $x
  math.add $x 10
enddef

addTen(15) into $result56r
test.assertEqual $result56r 25 "into syntax - user-defined function failed"

# Test 56s: Into with array indexing
range 1 5
$arr56s = $
array.length($arr56s) into $arr56s.length
test.assertEqual $arr56s.length 5 "into syntax - array indexing assignment failed"

# Test 56t: Multiple into statements in sequence
math.add 1 1 into $a56t
math.add 2 2 into $b56t
math.add 3 3 into $c56t
test.assertEqual $a56t 2 "into syntax - multiple statements first failed"
test.assertEqual $b56t 4 "into syntax - multiple statements second failed"
test.assertEqual $c56t 6 "into syntax - multiple statements third failed"

# Test 56u: Into with empty do block
do into $result56u
enddo
test.assertEqual $result56u null "into syntax - empty do block should return null"

# Test 56v: Into with do block that has parameters
do $x $y into $result56v
  math.add $x $y
enddo
test.assertEqual $result56v 0 "into syntax - do block with parameters (no args) should return 0"

# Test 56v2: Do block with parameters and into - isolated scope
$outerVar56v2 = 300
clear
do $a into $result56v2
  # Should not be able to access $outerVar56v2
  test.assertEqual $outerVar56v2 null "Isolated do with into should not access parent variables"
  test.assertEqual $a null "Parameter should be accessible (defaults to null)"
  $localVar = 400
  test.assertEqual $localVar 400 "Isolated do with into should allow local variables"
  math.add $a 10
enddo
test.assertEqual $outerVar56v2 300 "Parent variable should be unchanged after isolated do with into"
test.assertEqual $result56v2 10 "into syntax - isolated do with parameters should return result"

# Test 56v3: Do block with multiple parameters and into
$outerVar56v3 = 500
clear
do $x $y into $result56v3
  test.assertEqual $outerVar56v3 null "Isolated do with multiple params and into should not access parent"
  test.assertEqual $x null "First parameter should be accessible"
  test.assertEqual $y null "Second parameter should be accessible"
  math.add $x $y
enddo
test.assertEqual $outerVar56v3 500 "Parent variable should be unchanged"
test.assertEqual $result56v3 0 "into syntax - isolated do with multiple params (no args) should return 0"

# Test 56w: Into preserves last value after assignment
math.add 100 200
$beforeInto56w = $
math.add 5 5 into $result56w
test.assertEqual $beforeInto56w 300 "into syntax - should preserve last value"
test.assertEqual $result56w 10 "into syntax - should assign result correctly"

# Test 56x: Into with object literal
obj '{name: "Test", value: 42}' into $obj56x
test.assertEqual $obj56x.name "Test" "into syntax - object literal failed"
test.assertEqual $obj56x.value 42 "into syntax - object literal value failed"

# Test 56y: Into with array literal
array(1 2 3 4 5) into $arr56y
clear
do
  array.length $arr56y
  test.assertEqual $ 5 "into syntax - array literal length failed"
enddo
test.assertEqual $arr56y[2] 3 "into syntax - array literal element access failed"

log "Test 56 - into syntax sugar: All passed"

# Test 57: var and const commands
log "Test 57 - var and const commands"

# Test 57a: var command - declare variable without default value
var $testVar57a
test.assertEqual $testVar57a null "var command without default value failed"
log "Test 57a - var without default: passed"

# Test 57b: var command - declare variable with default value
var $testVar57b 42
test.assertEqual $testVar57b 42 "var command with default value failed"
log "Test 57b - var with default: passed"

# Test 57c: var command - declare variable with string default
var $testVar57c "hello"
test.assertEqual $testVar57c "hello" "var command with string default failed"
log "Test 57c - var with string default: passed"

# Test 57d: var command - cannot redeclare existing variable
var $testVar57d 10
test.assertEqual $testVar57d 10 "var first declaration failed"
# Note: Redeclaration test would throw error and stop execution
# This is tested manually: var $testVar57d 20 should throw error
log "Test 57d - var redeclaration (tested manually): passed"

# Test 57e: const command - declare constant with value
const $TEST_CONST_57e 100
test.assertEqual $TEST_CONST_57e 100 "const command failed"
log "Test 57e - const declaration: passed"

# Test 57f: const command - declare constant with string value
const $API_URL "https://api.example.com"
test.assertEqual $API_URL "https://api.example.com" "const command with string failed"
log "Test 57f - const with string: passed"

# Test 57g: const command - requires value argument
# Note: const $TEST_CONST_57g without value would throw error
# This is tested manually
log "Test 57g - const requires value (tested manually): passed"

# Test 57h: const command - cannot reassign constant with =
const $TEST_CONST_57h 50
# Note: $TEST_CONST_57h = 60 should throw error
# This is tested manually
log "Test 57h - const reassignment with = (tested manually): passed"

# Test 57i: const command - cannot reassign constant with set
const $TEST_CONST_57i 70
# Note: set $TEST_CONST_57i 80 should throw error
# This is tested manually
log "Test 57i - const reassignment with set (tested manually): passed"

# Test 57j: const command - cannot reassign constant with shorthand
const $TEST_CONST_57j 90
# Note: math.add 100 200 then $TEST_CONST_57j should throw error
# This is tested manually
log "Test 57j - const reassignment with shorthand (tested manually): passed"

# Test 57k: const command - cannot empty constant
const $TEST_CONST_57k 110
# Note: empty $TEST_CONST_57k should throw error
# This is tested manually
log "Test 57k - empty constant (tested manually): passed"

# Test 57l: const command - cannot redeclare existing constant
const $TEST_CONST_57l 120
# Note: const $TEST_CONST_57l 130 should throw error
# This is tested manually
log "Test 57l - const redeclaration (tested manually): passed"

# Test 57m: const command - cannot declare const if variable exists
var $testVar57m 140
# Note: const $testVar57m 150 should throw error
# This is tested manually
log "Test 57m - const declaration of existing variable (tested manually): passed"

# Test 57n: var command - cannot declare var if constant exists
const $TEST_CONST_57n 160
# Note: var $TEST_CONST_57n 170 should throw error
# This is tested manually
log "Test 57n - var declaration of existing constant (tested manually): passed"

# Test 57o: var and const - can read constants
const $READ_ONLY_CONST 180
test.assertEqual $READ_ONLY_CONST 180 "reading constant failed"
math.add $READ_ONLY_CONST 20
test.assertEqual $ 200 "using constant in expression failed"
log "Test 57o - reading constants: passed"

# Test 57p: var command - can reassign declared variable
var $mutableVar 200
test.assertEqual $mutableVar 200 "var initial value failed"
$mutableVar = 210
test.assertEqual $mutableVar 210 "var reassignment failed"
set $mutableVar 220
test.assertEqual $mutableVar 220 "var reassignment with set failed"
log "Test 57p - var reassignment: passed"

log "Test 57 - var and const commands: All passed"

# Test 58: Decorators with var and const
log "Test 58 - Decorators with var and const"

# Test 58a: @desc decorator with var
@desc "A test variable with description"
var $decoratedVar58a 42
test.assertEqual $decoratedVar58a 42 "decorated var value failed"
getMeta $decoratedVar58a description
test.assertEqual $ "A test variable with description" "@desc decorator with var failed"
log "Test 58a - @desc with var: passed"

# Test 58b: @description decorator with var (alias)
@description "Another test variable"
var $decoratedVar58b "hello"
test.assertEqual $decoratedVar58b "hello" "decorated var value failed"
getMeta $decoratedVar58b description
test.assertEqual $ "Another test variable" "@description decorator with var failed"
log "Test 58b - @description with var: passed"

# Test 58c: @title decorator with var
@title "Test Variable Title"
var $titledVar58c 100
test.assertEqual $titledVar58c 100 "titled var value failed"
getMeta $titledVar58c title
test.assertEqual $ "Test Variable Title" "@title decorator with var failed"
log "Test 58c - @title with var: passed"

# Test 58d: Multiple decorators with var
@desc "Variable with both description and title"
@title "Multi Decorator Variable"
var $multiDecoratedVar58d 200
test.assertEqual $multiDecoratedVar58d 200 "multi-decorated var value failed"
getMeta $multiDecoratedVar58d description
test.assertEqual $ "Variable with both description and title" "Multiple decorators - description failed"
getMeta $multiDecoratedVar58d title
test.assertEqual $ "Multi Decorator Variable" "Multiple decorators - title failed"
log "Test 58d - Multiple decorators with var: passed"

# Test 58e: @desc decorator with const
@desc "A test constant with description"
const $DECORATED_CONST_58e 300
test.assertEqual $DECORATED_CONST_58e 300 "decorated const value failed"
getMeta $DECORATED_CONST_58e description
test.assertEqual $ "A test constant with description" "@desc decorator with const failed"
log "Test 58e - @desc with const: passed"

# Test 58f: @title decorator with const
@title "Test Constant Title"
const $TITLED_CONST_58f 400
test.assertEqual $TITLED_CONST_58f 400 "titled const value failed"
getMeta $TITLED_CONST_58f title
test.assertEqual $ "Test Constant Title" "@title decorator with const failed"
log "Test 58f - @title with const: passed"

# Test 58g: Multiple decorators with const
@desc "Constant with both description and title"
@title "Multi Decorator Constant"
const $MULTI_DECORATED_CONST_58g 500
test.assertEqual $MULTI_DECORATED_CONST_58g 500 "multi-decorated const value failed"
getMeta $MULTI_DECORATED_CONST_58g description
test.assertEqual $ "Constant with both description and title" "Multiple decorators with const - description failed"
getMeta $MULTI_DECORATED_CONST_58g title
test.assertEqual $ "Multi Decorator Constant" "Multiple decorators with const - title failed"
log "Test 58g - Multiple decorators with const: passed"

# Test 58h: getMeta for decorated variable - return all metadata
@desc "Variable for getMeta all test"
@title "GetMeta All Test"
var $getMetaVar58h 600
getMeta $getMetaVar58h
$meta58h = $
test.assertType $meta58h "object" "getMeta all metadata should return an object"
test.assertEqual $meta58h.description "Variable for getMeta all test" "getMeta all metadata - description failed"
test.assertEqual $meta58h.title "GetMeta All Test" "getMeta all metadata - title failed"
log "Test 58h - getMeta all metadata with var: passed"

# Test 58i: getMeta for decorated constant - return all metadata
@desc "Constant for getMeta all test"
@title "GetMeta All Const Test"
const $GET_META_CONST_58i 700
getMeta $GET_META_CONST_58i
$meta58i = $
test.assertType $meta58i "object" "getMeta all metadata should return an object"
test.assertEqual $meta58i.description "Constant for getMeta all test" "getMeta all metadata - description failed"
test.assertEqual $meta58i.title "GetMeta All Const Test" "getMeta all metadata - title failed"
log "Test 58i - getMeta all metadata with const: passed"

log "Test 58 - Decorators with var and const: All passed"

log "All tests completed!"


